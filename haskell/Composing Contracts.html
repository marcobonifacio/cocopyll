
<!-- saved from url=(0072)http://web.archive.org/web/20130326233424/http://contracts.scheming.org/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><script src="./Composing Contracts_files/analytics.js.download" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app219.us.archive.org';v.server_ms=1140;archive_analytics.send_pageview({});});</script>
<script type="text/javascript" src="./Composing Contracts_files/bundle-playback.js.download" charset="utf-8"></script>
<script type="text/javascript" src="./Composing Contracts_files/wombat.js.download" charset="utf-8"></script>
<script>window.RufflePlayer=window.RufflePlayer||{};window.RufflePlayer.config={"autoplay":"on","unmuteOverlay":"hidden"};</script>
<script type="text/javascript" src="./Composing Contracts_files/ruffle.js.download"></script>
<script type="text/javascript">
  __wm.init("http://web.archive.org/web");
  __wm.wombat("http://contracts.scheming.org:80/","20130326233424","http://web.archive.org/","web","https://web-static.archive.org/_static/",
	      "1364340864");
</script>
<link rel="stylesheet" type="text/css" href="./Composing Contracts_files/banner-styles.css">
<link rel="stylesheet" type="text/css" href="./Composing Contracts_files/iconochive.css">
<!-- End Wayback Rewrite JS Include -->

<title>Composing Contracts</title>
<style>
body { margin-left: 0.25in; }
pre { background-color:#F0FEFF; border:1px solid #AFEFFF;
      font-size:14px; padding:5px; }
code { background-color:#F0FEFF; }

.varop     { color: grey;    }
.keyglyph  { color: #b8860b; }
.keyword   { color: #a020f0; }
.comment,
.comment a { color: #b22222; }
.str,
.chr       { color: #bc8f8f; }
.conid     { color: #228b22; }
.num       { color: orange; }
</style>
<meta name="Reverso extension" content="3.3.274" id="Reverso_extension___elForCheckedInstallExtension"></head>
<body data-feedly-mini="yes"><!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script>__wm.rw(0);</script>
<div id="wm-ipp-base" lang="en" style="display: block; direction: ltr;"><template shadowrootmode="closed"><div id="wm-ipp" style="position:fixed;left:0;top:0;right:0;" class="">
<div id="donato" style="position:relative;width:100%;">
  <div id="donato-base">
    <iframe id="donato-if" src="https://archive.org/includes/donate.php?as_page=1&amp;platform=wb&amp;referer=http%3A//web.archive.org/web/20130326233424/http%3A//contracts.scheming.org/" scrolling="no" frameborder="0" style="width:100%; height:100%">
    </iframe>
  </div>
</div><div id="wm-ipp-inside">
  <div id="wm-toolbar" style="position:relative;display:flex;flex-flow:row nowrap;justify-content:space-between;">
    <div id="wm-logo" style="/*width:110px;*/padding-top:12px;">
      <a href="http://web.archive.org/web/" title="Wayback Machine home page"><img src="https://web-static.archive.org/_static/images/toolbar/wayback-toolbar-logo-200.png" srcset="https://web-static.archive.org/_static/images/toolbar/wayback-toolbar-logo-100.png, https://web-static.archive.org/_static/images/toolbar/wayback-toolbar-logo-150.png 1.5x, https://web-static.archive.org/_static/images/toolbar/wayback-toolbar-logo-200.png 2x" alt="Wayback Machine" style="width:100px" border="0"></a>
    </div>
    <div class="c" style="display:flex;flex-flow:column nowrap;justify-content:space-between;flex:1;">
      <form class="u" style="display:flex;flex-direction:row;flex-wrap:nowrap;" target="_top" method="get" action="http://web.archive.org/web/submit" name="wmtb" id="wmtb"><input type="text" name="url" id="wmtbURL" value="http://contracts.scheming.org/" onfocus="this.focus();this.select();" style="flex:1;" autocomplete="off"><input type="hidden" name="type" value="replay"><input type="hidden" name="date" value="20130326233424"><input type="submit" value="Go">
      </form>
      <div style="display:flex;flex-flow:row nowrap;align-items:flex-end;">
                <div class="s" id="wm-nav-captures" style="flex:1;"><a class="t" href="http://web.archive.org/web/*/http://contracts.scheming.org/" title="See a list of every capture for this URL">22 captures</a><div class="r" title="Timespan for captures of this URL">27 Dec 2007 - 14 Aug 2013</div></div>
        <div class="k">
          <a href="http://web.archive.org/web/19990701000000/http://contracts.scheming.org/" id="wm-graph-anchor">
            <div id="wm-ipp-sparkline" title="Explore captures for this URL" style="position: relative">
              <canvas id="wm-sparkline-canvas" width="725" height="27" border="0"></canvas>
            <div class="yt" style="display: none; width: 25px; height: 27px; left: 75px;"></div><div class="mt" style="display: none; width: 2px; height: 27px; left: 88px;"></div></div>
          </a>
        </div>
      </div>
    </div>
    <div class="n">
      <table>
        <tbody>
          <!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
          <tr class="m">
            <td class="b" nowrap="nowrap"><a href="http://web.archive.org/web/20120623020058/http://contracts.scheming.org:80/" title="23 Jun 2012"><strong>Jun</strong></a></td>
            <td class="c" id="displayMonthEl" title="You are here: 23:34:24 Mar 26, 2013">Mar</td>
            <td class="f" nowrap="nowrap"><a href="http://web.archive.org/web/20130517082739/http://contracts.scheming.org:80/" title="17 May 2013"><strong>May</strong></a></td>
          </tr>
          <!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
          <tr class="d">
            <td class="b" nowrap="nowrap"><a href="http://web.archive.org/web/20120623020058/http://contracts.scheming.org:80/" title="02:00:58 Jun 23, 2012"><img src="https://web-static.archive.org/_static/images/toolbar/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0"></a></td>
            <td class="c" id="displayDayEl" style="width:34px;font-size:22px;white-space:nowrap;" title="You are here: 23:34:24 Mar 26, 2013">26</td>
            <td class="f" nowrap="nowrap"><a href="http://web.archive.org/web/20130517082739/http://contracts.scheming.org:80/" title="08:27:39 May 17, 2013"><img src="https://web-static.archive.org/_static/images/toolbar/wm_tb_nxt_on.png" alt="Next capture" width="14" height="16" border="0"></a></td>
          </tr>
          <!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
          <tr class="y">
            <td class="b" nowrap="nowrap"><a href="http://web.archive.org/web/20120309234150/http://contracts.scheming.org:80/" title="09 Mar 2012"><strong>2012</strong></a></td>
            <td class="c" id="displayYearEl" title="You are here: 23:34:24 Mar 26, 2013">2013</td>
            <td class="f" nowrap="nowrap">2014</td>
          </tr>
        </tbody>
      </table>
    </div>
    <div class="r" style="display:flex;flex-flow:column nowrap;align-items:flex-end;justify-content:space-between;">
      <div id="wm-btns" style="text-align:right;height:23px;">
                <span class="xxs">
          <div id="wm-save-snapshot-success">success</div>
          <div id="wm-save-snapshot-fail">fail</div>
          <a id="wm-save-snapshot-open" href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#" title="Share via My Web Archive" style="display: none;">
            <span class="iconochive-web"></span>
          </a>
          <a href="https://archive.org/account/login.php" title="Sign In" id="wm-sign-in" style="display: inline-block;">
            <span class="iconochive-person"></span>
          </a>
          <span id="wm-save-snapshot-in-progress" class="iconochive-web" style="display: none;"></span>
        </span>
                <a class="xxs" href="http://faq.web.archive.org/" title="Get some help using the Wayback Machine" style="top:-6px;"><span class="iconochive-question" style="color:rgb(87,186,244);font-size:160%;"></span></a>
        <a id="wm-tb-close" href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#close" style="top:-2px;" title="Close the toolbar"><span class="iconochive-remove-circle" style="color:#888888;font-size:240%;"></span></a>
      </div>
      <div id="wm-share" class="xxs">
        <a href="http://web.archive.org/web/20130326233424/http://web.archive.org/screenshot/http://contracts.scheming.org/" id="wm-screenshot" title="screenshot" style="visibility: hidden;">
          <span class="wm-icon-screen-shot"></span>
        </a>
        <a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#" id="wm-video" title="video">
          <span class="iconochive-movies"></span>
        </a>
        <a id="wm-share-facebook" href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#" data-url="http://web.archive.org/web/20130326233424/http://contracts.scheming.org:80/" title="Share on Facebook" style="margin-right:5px;" target="_blank"><span class="iconochive-facebook" style="color:#3b5998;font-size:160%;"></span></a>
        <a id="wm-share-twitter" href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#" data-url="http://web.archive.org/web/20130326233424/http://contracts.scheming.org:80/" title="Share on Twitter" style="margin-right:5px;" target="_blank"><span class="iconochive-twitter" style="color:#1dcaff;font-size:160%;"></span></a>
      </div>
      <div style="padding-right:2px;text-align:right;white-space:nowrap;">
        <a id="wm-expand" class="wm-btn wm-closed" href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#expand" onclick="__wm.ex(event);return false;"><span id="wm-expand-icon" class="iconochive-down-solid"></span> <span class="xxs" style="font-size:80%;">About this capture</span></a>
      </div>
    </div>
  </div>
    <div id="wm-capinfo" style="border-top:1px solid #777;display:none; overflow: hidden">
        <div id="wm-capinfo-notice" source="api"></div>
                <div id="wm-capinfo-collected-by">
    <div style="background-color:#666;color:#fff;font-weight:bold;text-align:center">COLLECTED BY</div>
    <div style="padding:3px;position:relative" id="wm-collected-by-content">
            <div style="display:inline-block;vertical-align:top;width:50%;">
			<span class="c-logo" style="background-image:url(https://archive.org/services/img/alexacrawls);"></span>
		Organization: <a style="color:#33f;" href="https://archive.org/details/alexacrawls" target="_new"><span class="wm-title">Alexa Crawls</span></a>
		<div style="max-height:75px;overflow:hidden;position:relative;">
	  <div style="position:absolute;top:0;left:0;width:100%;height:75px;background:linear-gradient(to bottom,rgba(255,255,255,0) 0%,rgba(255,255,255,0) 90%,rgba(255,255,255,255) 100%);"></div>
	  Starting in 1996, <a href="http://www.alexa.com/">Alexa Internet</a> has been donating their crawl data to the Internet Archive.  Flowing in every day, these data are added to the <a href="http://web.archive.org/">Wayback Machine</a> after an embargo period.
	</div>
	      </div>
      <div style="display:inline-block;vertical-align:top;width:49%;">
			<span class="c-logo" style="background-image:url(https://archive.org/services/img/alexacrawls)"></span>
		<div>Collection: <a style="color:#33f;" href="https://archive.org/details/alexacrawls" target="_new"><span class="wm-title">Alexa Crawls</span></a></div>
		<div style="max-height:75px;overflow:hidden;position:relative;">
	  <div style="position:absolute;top:0;left:0;width:100%;height:75px;background:linear-gradient(to bottom,rgba(255,255,255,0) 0%,rgba(255,255,255,0) 90%,rgba(255,255,255,255) 100%);"></div>
	  Starting in 1996, <a href="http://www.alexa.com/">Alexa Internet</a> has been donating their crawl data to the Internet Archive.  Flowing in every day, these data are added to the <a href="http://web.archive.org/">Wayback Machine</a> after an embargo period.
	</div>
	      </div>
    </div>
    </div>
    <div id="wm-capinfo-timestamps">
    <div style="background-color:#666;color:#fff;font-weight:bold;text-align:center" title="Timestamps for the elements of this page">TIMESTAMPS</div>
    <div>
      <div id="wm-capresources" style="margin:0 5px 5px 5px;max-height:250px;overflow-y:scroll !important"></div>
      <div id="wm-capresources-loading" style="text-align:left;margin:0 20px 5px 5px;display:none"><img src="https://web-static.archive.org/_static/images/loading.gif" alt="loading"></div>
    </div>
    </div>
  </div></div></div><link rel="stylesheet" type="text/css" href="./Composing Contracts_files/banner-styles.css"><link rel="stylesheet" type="text/css" href="./Composing Contracts_files/iconochive.css"><div class="wb-autocomplete-suggestions "></div></template>
</div><div id="wm-ipp-print">The Wayback Machine - http://web.archive.org/web/20130326233424/http://contracts.scheming.org:80/</div>
<script type="text/javascript">//<![CDATA[
__wm.bt(725,27,25,2,"web","http://contracts.scheming.org/","20130326233424",1996,"https://web-static.archive.org/_static/",["https://web-static.archive.org/_static/css/banner-styles.css?v=S1zqJCYt","https://web-static.archive.org/_static/css/iconochive.css?v=qtvMKcIJ"], false);
  __wm.rw(1);
//]]></script>
<!-- END WAYBACK TOOLBAR INSERT -->
 

<h1>Composing Contracts</h1>

<p>
This document is an unofficial example implementation of the system originally described in the paper <a href="http://web.archive.org/web/20130326233424/http://research.microsoft.com/~simonpj/Papers/financial-contracts/contracts-icfp.htm">
Composing contracts: an adventure in financial engineering</a>, by Simon Peyton Jones, Jean-Marc Eber, and Julian Seward.  Familiarity with both versions of this paper is assumed.
</p><p>
This example implementation is a literate Haskell program, <a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/Contracts.lhs">Contracts.lhs</a>.  Don't be put off by the embedded HTML — it is an executable Haskell program.  It can be executed directly and experimented with in an interactive Haskell environment such as <a href="http://web.archive.org/web/20130326233424/http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html#ghci-introduction">GHCI</a>.
</p><p>
The program is completely self contained, depending only on a few GHC libraries.  Compatibility with other Haskell implementations has not been tested.
</p><p>
A <a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/contractEx">web interface</a> to some of the examples is also available.
</p><p>
Please note that this program is an example, intended only for educational use in its current form.  The core implementation is only 215 lines of code, excluding examples and user interface.  As such, it has many limitations.  See the <a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#todo">Future work</a> section for further information.
</p><p>
This document and program was developed by, and is copyright © 2007 by <a href="http://web.archive.org/web/20130326233424/mailto:anton@appsolutions.com">Anton van Straaten</a>.  It may be freely used and copied for educational purposes.  For other uses, please contact the author (this is mainly because it seems like overkill to release under a more general license at this point).
</p>

<h2>Contents</h2>

<ul>
<li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#papers">A note about the original papers</a></li>
<li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#module">Module header</a></li>
<li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#notation">Notational conventions</a></li>
<li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#basictypes">Basic data types</a></li>
<li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#contract">Contract implementation</a></li>
<li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#obs">Observable data type</a></li>
<li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#contract-prims">Primitives for Defining Contracts</a></li>
<ul>
  <li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#derived">Derived combinators</a></li>
</ul>
<li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#obs-prims">Primitives over observables</a></li>
<ul>
  <li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#options">Option contracts</a></li>
</ul>
<li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#processes">Value processes</a>
<ul>
  <li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#valproc-helpers">Value process helpers</a></li>
</ul>
</li><li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#model">Model</a></li>
<ul>
  <li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#rates">Interest rate model</a></li>
  <li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#disc">'Disc' primitive</a></li>
  <li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#absorb">'Absorb' primitive</a></li>
  <li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#exch">Exchange rate model</a></li>
  <li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#expected">Expected value</a></li>
  <li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#snell">Snell primitive</a></li>
</ul>
<li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#probs">Probability calculation</a></li>
<li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#contract-eval">Compositional valuation semantics for contracts</a></li>
<li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#obs-eval">Valuation semantics for observables</a></li>
<li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#process-prims">Process primitives</a></li>
<li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#examples">Examples</a></li>
<ul>
  <li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#main">Main function</a></li>
  <li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#pretty">Pretty pictures</a></li>
  <ul>
    <li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#zcb-pic">Process lattice for zcb</a></li>
    <li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#expected-chart">Expected value</a></li>
    <li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#ratechart">Interest rate evolution
  </a></li></ul><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#ratechart">
</a></ul><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#ratechart">
</a><li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#ratechart"></a><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#todo">Future work</a></li>
<ul>
  <li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#time-handling">Support actual dates and times</a></li>
  <li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#evalarch">Implement monadic contract evaluator</a></li>
  <li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#obs-rep">Enhance observable representation</a></li>
  <li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#horizon-support">Improve contract horizon handling</a></li>
</ul>
<li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#appendixA">Appendix A - Tests</a></li>
<li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#appendixB">Appendix B - HTML table output for value process</a></li>
<li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#appendixC">Appendix C - Graphviz Output</a></li>
<li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#appendixD">Appendix D - Google chart</a></li>
<li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#appendixE">Appendix E - Web interface</a></li>
<ul>
  <li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#ExContr">Serializable example specification</a></li>
</ul>
<li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#appendixF">Appendix F - HAppS server integration</a></li>

<li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#references">References</a></li>
<li><a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#credits">Credits</a></li>
</ul>

<h2 id="papers">A note about the original papers</h2>

<p>
There are a few significant differences between the first and second papers.  The change with the most impact on the implementation relates to the representation of contract horizons.
</p><p>
In A:5.3, entitled "Implementation in Haskell", a value process representation is described in which the lattice for a value process is stored as a list of random variables "in reverse time order", i.e. horizon first, along with the horizon's timestep number.  This is possible because the first paper uses a simple, definite approach to representing horizons: they are specified by a single date.
</p><p>
However, this implementation is not compatible with some of the design decisions described in the second paper (B).  Since the horizon of a contract can depend on observables other than the date, the second paper introduces a more sophisticated approach to representing horizons: horizons are specified by boolean value processes (type <code>PR Bool</code>) that define contract acquisition regions.
</p><p>
This allows the horizon of a contract to cross over more than one time step, depending on the value of the observable(s) that define the horizon.  The use of boolean value processes "to describe the 'region' in which one can acquire a contract" is described as a "breakthrough" in section 3.6 of the second paper.
</p><p>
Since contracts can have indefinite horizons, and also because some value processes may have no horizon, it's not possible in general to represent a value process horizon-first, as suggested in the first paper.
</p><p>
Since the second paper does not provide an explicit description of the Haskell representation, our implementation uses a variation on the one described in the first paper, with some changes to support the second paper's design.
</p>

<h2 id="module">Module header</h2>

<pre> <span class="keyword">module</span> <span class="conid">Contracts</span>
 <span class="comment">-- (renderEx, renderExDefault, ExContr(ExContr)) -- limit exports for use from HAppS</span>
 <span class="keyword">where</span>
</pre>
<pre> <span class="keyword">import</span> <span class="conid">List</span>
 <span class="keyword">import</span> <span class="conid">Numeric</span>
 <span class="keyword">import</span> <span class="conid">Control</span><span class="varop">.</span><span class="conid">Monad</span>
 <span class="keyword">import</span> <span class="conid">System</span>
 <span class="keyword">import</span> <span class="conid">Text</span><span class="varop">.</span><span class="conid">XHtml</span><span class="varop">.</span><span class="conid">Strict</span>
 <span class="keyword">import</span> <span class="conid">Data</span><span class="varop">.</span><span class="conid">Unique</span>
</pre>
<h2 id="notation">Notational conventions</h2>
<p>
Most references in this document are of the form P:S.s, where e.g. A:3.5 refers to paper A, section 3.5.  The papers are listed in the <a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#references">References</a> section. Papers A and B are the first and second versions of the Composing Contracts paper, and paper C is a paper about the functional reactive programming system Fran.
</p><p></p>
Notational conventions from B:Fig.1:
<p></p>
<pre>c, d, u : Contract
      o : Observable
   t, s : Date, time
      k : Currency
      x : Dimensionless real value
      p : Value process
      v : Random variable
</pre>


<h2 id="basictypes">Basic data types</h2>

<pre> <span class="keyword">data</span> <span class="conid">Currency</span> <span class="keyglyph">=</span> <span class="conid">USD</span> <span class="keyglyph">|</span> <span class="conid">GBP</span> <span class="keyglyph">|</span> <span class="conid">EUR</span> <span class="keyglyph">|</span> <span class="conid">ZAR</span> <span class="keyglyph">|</span> <span class="conid">KYD</span> <span class="keyglyph">|</span> <span class="conid">CHF</span>  <span class="keyword">deriving</span> <span class="layout">(</span><span class="conid">Eq</span><span class="layout">,</span> <span class="conid">Show</span><span class="layout">)</span>
</pre>
<p>
A Date is represented as a pair consisting of the start date/time of a contract, represented by a value of type CalendarTime, and an integer representing the number of time steps since the start of a contract.  For example purposes, the time steps are of unspecified duration, and the CalendarTime type is stubbed out.
</p><p>
Representing the time step as a separate integer is useful when manipulating trees representing the evolution of a process over time, where the time step corresponds to an index into a list.
</p>

<pre> <span class="keyword">type</span> <span class="conid">Date</span> <span class="keyglyph">=</span> <span class="layout">(</span><span class="conid">CalendarTime</span><span class="layout">,</span> <span class="conid">TimeStep</span><span class="layout">)</span>
</pre>
<pre> <span class="keyword">type</span> <span class="conid">TimeStep</span> <span class="keyglyph">=</span> <span class="conid">Int</span>
 <span class="keyword">type</span> <span class="conid">CalendarTime</span> <span class="keyglyph">=</span> <span class="conid">()</span>
</pre>
Since the example doesn't use real dates, mkDate cheats and creates a Date from a TimeStep.

<pre> <span class="varid">mkDate</span> <span class="keyglyph">::</span> <span class="conid">TimeStep</span> <span class="keyglyph">-&gt;</span> <span class="conid">Date</span>
 <span class="varid">mkDate</span> <span class="varid">s</span> <span class="keyglyph">=</span> <span class="layout">(</span><span class="conid">()</span><span class="layout">,</span><span class="varid">s</span><span class="layout">)</span>
</pre>
Because real dates aren't used, all value processes are assumed to begin at the same time, the zeroth time step, <code>time0</code>.

<pre> <span class="varid">time0</span> <span class="keyglyph">::</span> <span class="conid">Date</span>
 <span class="varid">time0</span> <span class="keyglyph">=</span> <span class="varid">mkDate</span> <span class="num">0</span>
</pre>
This simplifies some aspects of the implementation, discussed further under <a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#time-handling">Support actual dates and times</a>.

<h2 id="contract">Contract implementation</h2>

The representation of a contract is based on A:5.3.

<pre> <span class="keyword">data</span> <span class="conid">Contract</span> <span class="keyglyph">=</span>
     <span class="conid">Zero</span>
   <span class="keyglyph">|</span> <span class="conid">One</span>  <span class="conid">Currency</span>
   <span class="keyglyph">|</span> <span class="conid">Give</span> <span class="conid">Contract</span>
   <span class="keyglyph">|</span> <span class="conid">And</span>  <span class="conid">Contract</span> <span class="conid">Contract</span>
   <span class="keyglyph">|</span> <span class="conid">Or</span>   <span class="conid">Contract</span> <span class="conid">Contract</span>
   <span class="keyglyph">|</span> <span class="conid">Cond</span>    <span class="layout">(</span><span class="conid">Obs</span> <span class="conid">Bool</span><span class="layout">)</span>   <span class="conid">Contract</span> <span class="conid">Contract</span>
   <span class="keyglyph">|</span> <span class="conid">Scale</span>   <span class="layout">(</span><span class="conid">Obs</span> <span class="conid">Double</span><span class="layout">)</span> <span class="conid">Contract</span>
   <span class="keyglyph">|</span> <span class="conid">When</span>    <span class="layout">(</span><span class="conid">Obs</span> <span class="conid">Bool</span><span class="layout">)</span>   <span class="conid">Contract</span>
   <span class="keyglyph">|</span> <span class="conid">Anytime</span> <span class="layout">(</span><span class="conid">Obs</span> <span class="conid">Bool</span><span class="layout">)</span>   <span class="conid">Contract</span>
   <span class="keyglyph">|</span> <span class="conid">Until</span>   <span class="layout">(</span><span class="conid">Obs</span> <span class="conid">Bool</span><span class="layout">)</span>   <span class="conid">Contract</span>
   <span class="keyword">deriving</span> <span class="conid">Show</span>
</pre>

<h2 id="obs">Observable data type</h2>

<p>
"In general, a value of type <code>Obs <i>d</i></code> represents a time-varying quantity of type <code><i>d</i></code>." (A:3.3)
</p><p>
An obvious implementation might involve a function of type <code>(Date -&gt; a)</code>.  However, a "quantity" in this context is not a single value, but rather a random variable, i.e. a set of possible values.  This suggests a function of type <code>(Date -&gt; RV a)</code>.  This would allow an arbitrary observable to be converted to a value process during evaluation of a contract, by applying successive dates to the observable's function.  This would be a valid implementation, but in order to take maximum advantage of the lazy list representation used for value processes, we will actually use the following type:
</p>

<pre> <span class="keyword">newtype</span> <span class="conid">Obs</span> <span class="varid">a</span> <span class="keyglyph">=</span> <span class="conid">Obs</span> <span class="layout">(</span><span class="conid">Date</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varid">a</span><span class="layout">)</span>
</pre>
<p>
An observable is thus represented as a function from a starting date to a value process.  The "time-varying" nature of an observable is captured primarily by the value process itself (<code>PR a</code>); the <code>Date</code> in the function's type is simply used to specify the start date for the resulting value process.
</p><p>
For development and debugging purposes, Obs will be showable.  Since it is a function type, this is achieved by applying it to a dummy date and displaying the first slice of the resulting process.  This is only useful for getting a rough idea of the definition of a contract.  See <a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#obs-rep">Enhance observable representation</a> for further discussion of this.
</p>

<pre> <span class="keyword">instance</span> <span class="conid">Show</span> <span class="varid">a</span> <span class="keyglyph">=&gt;</span> <span class="conid">Show</span> <span class="layout">(</span><span class="conid">Obs</span> <span class="varid">a</span><span class="layout">)</span> <span class="keyword">where</span>
   <span class="varid">show</span> <span class="layout">(</span><span class="conid">Obs</span> <span class="varid">o</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="keyword">let</span> <span class="layout">(</span><span class="conid">PR</span> <span class="layout">(</span><span class="varid">rv</span><span class="conop">:</span><span class="keyword">_</span><span class="layout">)</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">o</span> <span class="varid">time0</span> <span class="keyword">in</span> <span class="str">"(Obs "</span> <span class="varop">++</span> <span class="varid">show</span> <span class="varid">rv</span> <span class="varop">++</span> <span class="str">")"</span>
</pre>
<h2 id="contract-prims">Primitives for Defining Contracts</h2>

Define a combinator interface to the Contract datatype.  From B:Fig.2:

<pre> <span class="varid">zero</span> <span class="keyglyph">::</span> <span class="conid">Contract</span>
 <span class="varid">zero</span> <span class="keyglyph">=</span> <span class="conid">Zero</span>
</pre>
<pre> <span class="varid">one</span> <span class="keyglyph">::</span> <span class="conid">Currency</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span>
 <span class="varid">one</span> <span class="keyglyph">=</span> <span class="conid">One</span>
</pre>
<pre> <span class="varid">give</span> <span class="keyglyph">::</span> <span class="conid">Contract</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span>
 <span class="varid">give</span> <span class="keyglyph">=</span> <span class="conid">Give</span>
</pre>
<pre> <span class="varid">cAnd</span> <span class="keyglyph">::</span> <span class="conid">Contract</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span>
 <span class="varid">cAnd</span> <span class="keyglyph">=</span> <span class="conid">And</span>
</pre>
<pre> <span class="varid">cOr</span> <span class="keyglyph">::</span> <span class="conid">Contract</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span>
 <span class="varid">cOr</span> <span class="keyglyph">=</span> <span class="conid">Or</span>
</pre>
<pre> <span class="varid">cond</span> <span class="keyglyph">::</span> <span class="conid">Obs</span> <span class="conid">Bool</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span>
 <span class="varid">cond</span> <span class="keyglyph">=</span> <span class="conid">Cond</span>
</pre>
<pre> <span class="varid">scale</span> <span class="keyglyph">::</span> <span class="conid">Obs</span> <span class="conid">Double</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span>
 <span class="varid">scale</span> <span class="keyglyph">=</span> <span class="conid">Scale</span>
</pre>
<pre> <span class="varid">cWhen</span> <span class="keyglyph">::</span> <span class="conid">Obs</span> <span class="conid">Bool</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span>
 <span class="varid">cWhen</span> <span class="keyglyph">=</span> <span class="conid">When</span>
</pre>
<pre> <span class="varid">anytime</span> <span class="keyglyph">::</span> <span class="conid">Obs</span> <span class="conid">Bool</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span>
 <span class="varid">anytime</span> <span class="keyglyph">=</span> <span class="conid">Anytime</span>
</pre>
<pre> <span class="varid">cUntil</span> <span class="keyglyph">::</span> <span class="conid">Obs</span> <span class="conid">Bool</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span>
 <span class="varid">cUntil</span> <span class="keyglyph">=</span> <span class="conid">Until</span>
</pre>

<h3 id="derived">Derived combinators</h3>

Other combinators can now be derived from these primitives, e.g.:

<pre> <span class="varid">andGive</span> <span class="keyglyph">::</span> <span class="conid">Contract</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span>
 <span class="varid">andGive</span> <span class="varid">c</span> <span class="varid">d</span> <span class="keyglyph">=</span> <span class="varid">c</span> <span class="varop">`cAnd`</span> <span class="varid">give</span> <span class="varid">d</span>
</pre>

<h2 id="obs-prims">Primitives over observables</h2>

<code>konst x</code> is an observable that has value x at any time.

<pre> <span class="varid">konst</span> <span class="keyglyph">::</span> <span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="conid">Obs</span> <span class="varid">a</span>
 <span class="varid">konst</span> <span class="varid">k</span> <span class="keyglyph">=</span> <span class="conid">Obs</span> <span class="layout">(</span><span class="keyglyph">\</span><span class="varid">t</span> <span class="keyglyph">-&gt;</span> <span class="varid">bigK</span> <span class="varid">k</span><span class="layout">)</span>
</pre>
<code>lift f o</code> is the observable whose value is the result of applying f to the value of the observable o.

<pre> <span class="varid">lift</span> <span class="keyglyph">::</span> <span class="layout">(</span><span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="varid">b</span><span class="layout">)</span> <span class="keyglyph">-&gt;</span> <span class="conid">Obs</span> <span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="conid">Obs</span> <span class="varid">b</span>
 <span class="varid">lift</span> <span class="varid">f</span> <span class="layout">(</span><span class="conid">Obs</span> <span class="varid">o</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="conid">Obs</span> <span class="layout">(</span><span class="keyglyph">\</span><span class="varid">t</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varop">$</span> <span class="varid">map</span> <span class="layout">(</span><span class="varid">map</span> <span class="varid">f</span><span class="layout">)</span> <span class="layout">(</span><span class="varid">unPr</span> <span class="varop">$</span> <span class="varid">o</span> <span class="varid">t</span><span class="layout">)</span><span class="layout">)</span>
</pre>
<code>lift<sub>2</sub> o<sub>1</sub> o<sub>2</sub></code> is the observable whose value is the result of applying 
f to the values of the observables <code>o<sub>1</sub> o<sub>2</sub></code>.

<pre> <span class="varid">lift2</span> <span class="keyglyph">::</span> <span class="layout">(</span><span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="varid">b</span> <span class="keyglyph">-&gt;</span> <span class="varid">c</span><span class="layout">)</span> <span class="keyglyph">-&gt;</span> <span class="conid">Obs</span> <span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="conid">Obs</span> <span class="varid">b</span> <span class="keyglyph">-&gt;</span> <span class="conid">Obs</span> <span class="varid">c</span>
 <span class="varid">lift2</span> <span class="varid">f</span> <span class="layout">(</span><span class="conid">Obs</span> <span class="varid">o1</span><span class="layout">)</span> <span class="layout">(</span><span class="conid">Obs</span> <span class="varid">o2</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="conid">Obs</span> <span class="layout">(</span><span class="keyglyph">\</span><span class="varid">t</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varop">$</span> <span class="varid">zipWith</span> <span class="layout">(</span><span class="varid">zipWith</span> <span class="varid">f</span><span class="layout">)</span> <span class="layout">(</span><span class="varid">unPr</span> <span class="varop">$</span> <span class="varid">o1</span> <span class="varid">t</span><span class="layout">)</span> <span class="layout">(</span><span class="varid">unPr</span> <span class="varop">$</span> <span class="varid">o2</span> <span class="varid">t</span><span class="layout">)</span><span class="layout">)</span>
</pre>
"The value of the observable <code>date</code> at date <code>t</code> is just <code>t</code>."

<pre> <span class="varid">date</span> <span class="keyglyph">::</span> <span class="conid">Obs</span> <span class="conid">Date</span>
 <span class="varid">date</span> <span class="keyglyph">=</span> <span class="conid">Obs</span> <span class="layout">(</span><span class="keyglyph">\</span><span class="varid">t</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varop">$</span> <span class="varid">timeSlices</span> <span class="keyglyph">[</span><span class="varid">t</span><span class="keyglyph">]</span><span class="layout">)</span>
</pre>
"All numeric operations lift to the Obs type. The implementation is simple, using lift and 
lift<sub>2</sub>."

<pre> <span class="keyword">instance</span> <span class="conid">Num</span> <span class="varid">a</span> <span class="keyglyph">=&gt;</span> <span class="conid">Num</span> <span class="layout">(</span><span class="conid">Obs</span> <span class="varid">a</span><span class="layout">)</span> <span class="keyword">where</span>
   <span class="varid">fromInteger</span> <span class="varid">i</span> <span class="keyglyph">=</span> <span class="varid">konst</span> <span class="layout">(</span><span class="varid">fromInteger</span> <span class="varid">i</span><span class="layout">)</span>
   <span class="layout">(</span><span class="varop">+</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">lift2</span> <span class="layout">(</span><span class="varop">+</span><span class="layout">)</span>
   <span class="layout">(</span><span class="comment">-</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">lift2</span> <span class="layout">(</span><span class="comment">-</span><span class="layout">)</span>
   <span class="layout">(</span><span class="varop">*</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">lift2</span> <span class="layout">(</span><span class="varop">*</span><span class="layout">)</span>
   <span class="varid">abs</span> <span class="keyglyph">=</span> <span class="varid">lift</span> <span class="varid">abs</span>
   <span class="varid">signum</span> <span class="keyglyph">=</span> <span class="varid">lift</span> <span class="varid">signum</span>
</pre>
One quirk is that we need to define a stub for Eq to support the Num instance.

<pre> <span class="keyword">instance</span> <span class="conid">Eq</span> <span class="varid">a</span> <span class="keyglyph">=&gt;</span> <span class="conid">Eq</span> <span class="layout">(</span><span class="conid">Obs</span> <span class="varid">a</span><span class="layout">)</span> <span class="keyword">where</span>
   <span class="layout">(</span><span class="varop">==</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">undefined</span>
</pre>
We can't implement Eq on an Observable's function, but we can provide a lifted version of equality:

<pre> <span class="layout">(</span><span class="varop">==*</span><span class="layout">)</span> <span class="keyglyph">::</span> <span class="conid">Ord</span> <span class="varid">a</span> <span class="keyglyph">=&gt;</span> <span class="conid">Obs</span> <span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="conid">Obs</span> <span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="conid">Obs</span> <span class="conid">Bool</span>
 <span class="layout">(</span><span class="varop">==*</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">lift2</span> <span class="layout">(</span><span class="varop">==</span><span class="layout">)</span>
</pre>

<code>at</code> is a boolean observable that becomes <code>True</code> at time <code>t</code> (B:3.2)

<pre> <span class="varid">at</span> <span class="keyglyph">::</span> <span class="conid">Date</span> <span class="keyglyph">-&gt;</span> <span class="conid">Obs</span> <span class="conid">Bool</span>
 <span class="varid">at</span> <span class="varid">t</span> <span class="keyglyph">=</span> <span class="varid">date</span> <span class="varop">==*</span> <span class="layout">(</span><span class="varid">konst</span> <span class="varid">t</span><span class="layout">)</span>
</pre>
Typeclasses don't work so well for relational operators, so define a separate family of them (B:3.3)

<pre> <span class="layout">(</span><span class="varop">%&lt;</span><span class="layout">)</span><span class="layout">,</span> <span class="layout">(</span><span class="varop">%&lt;=</span><span class="layout">)</span><span class="layout">,</span> <span class="layout">(</span><span class="varop">%=</span><span class="layout">)</span><span class="layout">,</span> <span class="layout">(</span><span class="varop">%&gt;=</span><span class="layout">)</span><span class="layout">,</span> <span class="layout">(</span><span class="varop">%&gt;</span><span class="layout">)</span> <span class="keyglyph">::</span> <span class="conid">Ord</span> <span class="varid">a</span> <span class="keyglyph">=&gt;</span> <span class="conid">Obs</span> <span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="conid">Obs</span> <span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="conid">Obs</span> <span class="conid">Bool</span>
 <span class="layout">(</span><span class="varop">%&lt;</span><span class="layout">)</span>  <span class="keyglyph">=</span> <span class="varid">lift2</span> <span class="layout">(</span><span class="varop">&lt;</span><span class="layout">)</span>
 <span class="layout">(</span><span class="varop">%&lt;=</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">lift2</span> <span class="layout">(</span><span class="varop">&lt;=</span><span class="layout">)</span>
 <span class="layout">(</span><span class="varop">%=</span><span class="layout">)</span>  <span class="keyglyph">=</span> <span class="varid">lift2</span> <span class="layout">(</span><span class="varop">==</span><span class="layout">)</span>
 <span class="layout">(</span><span class="varop">%&gt;=</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">lift2</span> <span class="layout">(</span><span class="varop">&gt;=</span><span class="layout">)</span>
 <span class="layout">(</span><span class="varop">%&gt;</span><span class="layout">)</span>  <span class="keyglyph">=</span> <span class="varid">lift2</span> <span class="layout">(</span><span class="varop">&gt;</span><span class="layout">)</span>
</pre>

<h3 id="options">Option contracts</h3>

From B:3.4:

<pre> <span class="varid">european</span> <span class="keyglyph">::</span> <span class="conid">Date</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span>
 <span class="varid">european</span> <span class="varid">t</span> <span class="varid">u</span> <span class="keyglyph">=</span> <span class="varid">cWhen</span> <span class="layout">(</span><span class="varid">at</span> <span class="varid">t</span><span class="layout">)</span> <span class="layout">(</span><span class="varid">u</span> <span class="varop">`cOr`</span> <span class="varid">zero</span><span class="layout">)</span>
</pre>
<pre> <span class="varid">american</span> <span class="keyglyph">::</span> <span class="layout">(</span><span class="conid">Date</span><span class="layout">,</span> <span class="conid">Date</span><span class="layout">)</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span>
 <span class="varid">american</span> <span class="layout">(</span><span class="varid">t1</span><span class="layout">,</span> <span class="varid">t2</span><span class="layout">)</span> <span class="varid">u</span> <span class="keyglyph">=</span> <span class="varid">anytime</span> <span class="layout">(</span><span class="varid">between</span> <span class="varid">t1</span> <span class="varid">t2</span><span class="layout">)</span> <span class="varid">u</span>
</pre>
<pre> <span class="varid">between</span> <span class="keyglyph">::</span> <span class="conid">Date</span> <span class="keyglyph">-&gt;</span> <span class="conid">Date</span> <span class="keyglyph">-&gt;</span> <span class="conid">Obs</span> <span class="conid">Bool</span>
 <span class="varid">between</span> <span class="varid">t1</span> <span class="varid">t2</span> <span class="keyglyph">=</span> <span class="varid">lift2</span> <span class="layout">(</span><span class="varop">&amp;&amp;</span><span class="layout">)</span> <span class="layout">(</span><span class="varid">date</span> <span class="varop">%&gt;=</span> <span class="layout">(</span><span class="varid">konst</span> <span class="varid">t1</span><span class="layout">)</span><span class="layout">)</span> <span class="layout">(</span><span class="varid">date</span> <span class="varop">%&lt;=</span> <span class="layout">(</span><span class="varid">konst</span> <span class="varid">t2</span><span class="layout">)</span><span class="layout">)</span>
</pre>

<h2 id="processes">Value processes</h2>

A value process <code>PR a</code> is represented as a list of random variables <code>RV a</code>, with the random variable corresponding to the earliest time step appearing first in the list.

<pre> <span class="keyword">newtype</span> <span class="conid">PR</span> <span class="varid">a</span> <span class="keyglyph">=</span> <span class="conid">PR</span> <span class="layout">{</span> <span class="varid">unPr</span> <span class="keyglyph">::</span> <span class="keyglyph">[</span><span class="conid">RV</span> <span class="varid">a</span><span class="keyglyph">]</span> <span class="layout">}</span> <span class="keyword">deriving</span> <span class="conid">Show</span>
</pre>
<p>
Note that the "informal type definition" of a value process is given in B:4.1 as <code>PR a = Date -&gt; RV a</code>.  However, this definition should not be taken literally.  Among other things, it is not amenable to efficient list-based recursive processing of entire value processes, since it requires a lookup for access to each successive date.  (This was discovered the hard way in an earlier implementation of this code — thanks to Chung-chieh Shan for pointing out the advantages of relying pervasively on a lazy list implementation, during the presentation of the earlier version of this code in NYC.)
</p><p>
A random variable <code>RV a</code> describes the possible values for a value process at a particular time step.  For example, the random variable describing the outcome of a dice throw would be <code>[1,2,3,4,5,6]</code>.  Random variables are therefore implemented as simple lists.
</p>

<pre> <span class="keyword">type</span> <span class="conid">RV</span> <span class="varid">a</span> <span class="keyglyph">=</span> <span class="keyglyph">[</span><span class="varid">a</span><span class="keyglyph">]</span>
</pre>
<h3 id="valproc-helpers">Value process helpers</h3>

<code>takePr</code> truncates a (possibly infinite) value process.

<pre> <span class="varid">takePr</span> <span class="keyglyph">::</span> <span class="conid">Int</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varid">a</span>
 <span class="varid">takePr</span> <span class="varid">n</span> <span class="layout">(</span><span class="conid">PR</span> <span class="varid">rvs</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="conid">PR</span> <span class="varop">$</span> <span class="varid">take</span> <span class="varid">n</span> <span class="varid">rvs</span>
</pre>
<code>horizonPr</code> determines the number of time steps in a value process. Only terminates for finite value processes.

<pre> <span class="varid">horizonPr</span> <span class="keyglyph">::</span> <span class="conid">PR</span> <span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="conid">Int</span>
 <span class="varid">horizonPr</span> <span class="layout">(</span><span class="conid">PR</span> <span class="varid">rvs</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">length</span> <span class="varid">rvs</span>
</pre>
<code>andPr</code> returns True if every value in a value process is true, false otherwise.  Only terminates for finite value processes.

<pre> <span class="varid">andPr</span> <span class="keyglyph">::</span> <span class="conid">PR</span> <span class="conid">Bool</span> <span class="keyglyph">-&gt;</span> <span class="conid">Bool</span>
 <span class="varid">andPr</span> <span class="layout">(</span><span class="conid">PR</span> <span class="varid">rvs</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">and</span> <span class="layout">(</span><span class="varid">map</span> <span class="varid">and</span> <span class="varid">rvs</span><span class="layout">)</span>
</pre>
<h2 id="model">Model</h2>

<p>
The model specifies the particular semantics for underlying observables such as the evolution of interest rates, exchange rates, and the types of calculation used.  The contract evaluation function, evalC, is parameterized over a model to allow different models to be easily used.
</p><p>
The model itself is implemented as a record of model-specific data and functions which can easily be instantiated by a function such as <code>exampleModel</code> below.  Essentially, this amounts to a poor man's higher-order module.
</p>

<pre> <span class="keyword">data</span> <span class="conid">Model</span> <span class="keyglyph">=</span> <span class="conid">Model</span> <span class="layout">{</span>
   <span class="varid">modelStart</span> <span class="keyglyph">::</span> <span class="conid">Date</span><span class="layout">,</span>
   <span class="varid">disc</span>       <span class="keyglyph">::</span> <span class="conid">Currency</span> <span class="keyglyph">-&gt;</span> <span class="layout">(</span><span class="conid">PR</span> <span class="conid">Bool</span><span class="layout">,</span> <span class="conid">PR</span> <span class="conid">Double</span><span class="layout">)</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="conid">Double</span><span class="layout">,</span>
   <span class="varid">exch</span>       <span class="keyglyph">::</span> <span class="conid">Currency</span> <span class="keyglyph">-&gt;</span> <span class="conid">Currency</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="conid">Double</span><span class="layout">,</span>
   <span class="varid">absorb</span>     <span class="keyglyph">::</span> <span class="conid">Currency</span> <span class="keyglyph">-&gt;</span> <span class="layout">(</span><span class="conid">PR</span> <span class="conid">Bool</span><span class="layout">,</span> <span class="conid">PR</span> <span class="conid">Double</span><span class="layout">)</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="conid">Double</span><span class="layout">,</span>
   <span class="varid">rateModel</span>  <span class="keyglyph">::</span> <span class="conid">Currency</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="conid">Double</span>
   <span class="layout">}</span>
</pre>
Define a specific model which defines the model functions given in the paper.
This would normally be defined in a separate module.

<pre> <span class="varid">exampleModel</span> <span class="keyglyph">::</span> <span class="conid">CalendarTime</span> <span class="keyglyph">-&gt;</span> <span class="conid">Model</span>
 <span class="varid">exampleModel</span> <span class="varid">modelDate</span> <span class="keyglyph">=</span> <span class="conid">Model</span> <span class="layout">{</span>
   <span class="varid">modelStart</span> <span class="keyglyph">=</span> <span class="layout">(</span><span class="varid">modelDate</span><span class="layout">,</span><span class="num">0</span><span class="layout">)</span><span class="layout">,</span>
   <span class="varid">disc</span>       <span class="keyglyph">=</span> <span class="varid">disc</span><span class="layout">,</span>
   <span class="varid">exch</span>       <span class="keyglyph">=</span> <span class="varid">exch</span><span class="layout">,</span>
   <span class="varid">absorb</span>     <span class="keyglyph">=</span> <span class="varid">absorb</span><span class="layout">,</span>
   <span class="varid">rateModel</span>  <span class="keyglyph">=</span> <span class="varid">rateModel</span>
   <span class="layout">}</span>
</pre>
<pre>   <span class="keyword">where</span>
</pre>
The example model's functions are defined in the following sections.  Note that these definitions are local to the <code>exampleModel</code> record definition (due to the <code>where</code> clause above).

<h3 id="rates">Interest rate model</h3>
<p>
See B:5.1.  This constructs a lattice containing possible interest rates given a starting rate and an increment per time step.
This "unrealistically regular" model matches that shown in B:Fig.8.  However, it is so simple that some interest rates go negative after a small number of time steps.  A better model is needed for real applications.  Don't use this to model your retirement fund!
</p><p>

</p><pre>   <span class="varid">rates</span> <span class="keyglyph">::</span> <span class="conid">Double</span> <span class="keyglyph">-&gt;</span> <span class="conid">Double</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="conid">Double</span>
   <span class="varid">rates</span> <span class="varid">rateNow</span> <span class="varid">delta</span> <span class="keyglyph">=</span> <span class="conid">PR</span> <span class="varop">$</span> <span class="varid">makeRateSlices</span> <span class="varid">rateNow</span> <span class="num">1</span>
     <span class="keyword">where</span>
       <span class="varid">makeRateSlices</span> <span class="varid">rateNow</span> <span class="varid">n</span> <span class="keyglyph">=</span> <span class="layout">(</span><span class="varid">rateSlice</span> <span class="varid">rateNow</span> <span class="varid">n</span><span class="layout">)</span> <span class="conop">:</span> <span class="layout">(</span><span class="varid">makeRateSlices</span> <span class="layout">(</span><span class="varid">rateNow</span><span class="comment">-</span><span class="varid">delta</span><span class="layout">)</span> <span class="layout">(</span><span class="varid">n</span><span class="varop">+</span><span class="num">1</span><span class="layout">)</span><span class="layout">)</span>
       <span class="varid">rateSlice</span> <span class="varid">minRate</span> <span class="varid">n</span> <span class="keyglyph">=</span> <span class="varid">take</span> <span class="varid">n</span> <span class="keyglyph">[</span><span class="varid">minRate</span><span class="layout">,</span> <span class="varid">minRate</span><span class="varop">+</span><span class="layout">(</span><span class="varid">delta</span><span class="varop">*</span><span class="num">2</span><span class="layout">)</span> <span class="keyglyph">..</span><span class="keyglyph">]</span>
</pre>
Each currency has different parameters for the interest rate model.  Since the model is not realistic, these parameters are currently entirely arbitrary.

<pre>   <span class="varid">rateModels</span> <span class="keyglyph">=</span> <span class="keyglyph">[</span><span class="layout">(</span><span class="conid">CHF</span><span class="layout">,</span> <span class="varid">rates</span> <span class="num">7</span>   <span class="num">0.8</span><span class="layout">)</span>
                <span class="layout">,</span><span class="layout">(</span><span class="conid">EUR</span><span class="layout">,</span> <span class="varid">rates</span> <span class="num">6.5</span> <span class="num">0.25</span><span class="layout">)</span>
                <span class="layout">,</span><span class="layout">(</span><span class="conid">GBP</span><span class="layout">,</span> <span class="varid">rates</span> <span class="num">8</span>   <span class="num">0.5</span><span class="layout">)</span>
                <span class="layout">,</span><span class="layout">(</span><span class="conid">KYD</span><span class="layout">,</span> <span class="varid">rates</span> <span class="num">11</span>  <span class="num">1.2</span><span class="layout">)</span>
                <span class="layout">,</span><span class="layout">(</span><span class="conid">USD</span><span class="layout">,</span> <span class="varid">rates</span> <span class="num">5</span>   <span class="num">1</span><span class="layout">)</span>
                <span class="layout">,</span><span class="layout">(</span><span class="conid">ZAR</span><span class="layout">,</span> <span class="varid">rates</span> <span class="num">15</span>  <span class="num">1.5</span><span class="layout">)</span>
                <span class="keyglyph">]</span>
</pre>
<pre>   <span class="varid">rateModel</span> <span class="varid">k</span> <span class="keyglyph">=</span>
     <span class="keyword">case</span> <span class="varid">lookup</span> <span class="varid">k</span> <span class="varid">rateModels</span> <span class="keyword">of</span>
       <span class="conid">Just</span> <span class="varid">x</span> <span class="keyglyph">-&gt;</span> <span class="varid">x</span>
       <span class="conid">Nothing</span> <span class="keyglyph">-&gt;</span> <span class="varid">error</span> <span class="varop">$</span> <span class="str">"rateModel: currency not found "</span> <span class="varop">++</span> <span class="layout">(</span><span class="varid">show</span> <span class="varid">k</span><span class="layout">)</span>
</pre>
<h3 id="disc">'Disc' primitive</h3>
<p>
The primitive (disc t k) maps a real-valued random variable at date T, expressed in currency k,
to its "fair" equivalent stochastic value process in the same currency k.  See B:4.4 and B:Fig.7.
</p><p>
A simplifying assumption is that at some point, the boolean-valued process becomes True for an entire RV.  This provides a simple termination condition for the discounting process.
</p>

<pre>   <span class="varid">disc</span> <span class="keyglyph">::</span> <span class="conid">Currency</span> <span class="keyglyph">-&gt;</span> <span class="layout">(</span><span class="conid">PR</span> <span class="conid">Bool</span><span class="layout">,</span> <span class="conid">PR</span> <span class="conid">Double</span><span class="layout">)</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="conid">Double</span>
   <span class="varid">disc</span> <span class="varid">k</span> <span class="layout">(</span><span class="conid">PR</span> <span class="varid">bs</span><span class="layout">,</span> <span class="conid">PR</span> <span class="varid">rs</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="conid">PR</span> <span class="varop">$</span> <span class="varid">discCalc</span> <span class="varid">bs</span> <span class="varid">rs</span> <span class="layout">(</span><span class="varid">unPr</span> <span class="varop">$</span> <span class="varid">rateModel</span> <span class="varid">k</span><span class="layout">)</span>
</pre>
<pre>     <span class="keyword">where</span>
</pre>
<pre>       <span class="varid">discCalc</span> <span class="keyglyph">::</span> <span class="keyglyph">[</span><span class="conid">RV</span> <span class="conid">Bool</span><span class="keyglyph">]</span> <span class="keyglyph">-&gt;</span> <span class="keyglyph">[</span><span class="conid">RV</span> <span class="conid">Double</span><span class="keyglyph">]</span> <span class="keyglyph">-&gt;</span> <span class="keyglyph">[</span><span class="conid">RV</span> <span class="conid">Double</span><span class="keyglyph">]</span> <span class="keyglyph">-&gt;</span> <span class="keyglyph">[</span><span class="conid">RV</span> <span class="conid">Double</span><span class="keyglyph">]</span>
       <span class="varid">discCalc</span> <span class="layout">(</span><span class="varid">bRv</span><span class="conop">:</span><span class="varid">bs</span><span class="layout">)</span> <span class="layout">(</span><span class="varid">pRv</span><span class="conop">:</span><span class="varid">ps</span><span class="layout">)</span> <span class="layout">(</span><span class="varid">rateRv</span><span class="conop">:</span><span class="varid">rs</span><span class="layout">)</span> <span class="keyglyph">=</span>
         <span class="keyword">if</span> <span class="varid">and</span> <span class="varid">bRv</span> <span class="comment">-- test for horizon</span>
           <span class="keyword">then</span> <span class="keyglyph">[</span><span class="varid">pRv</span><span class="keyglyph">]</span>
           <span class="keyword">else</span> <span class="keyword">let</span> <span class="varid">rest</span><span class="keyglyph">@</span><span class="layout">(</span><span class="varid">nextSlice</span><span class="conop">:</span><span class="keyword">_</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">discCalc</span> <span class="varid">bs</span> <span class="varid">ps</span> <span class="varid">rs</span>
                    <span class="varid">discSlice</span> <span class="keyglyph">=</span> <span class="varid">zipWith</span> <span class="layout">(</span><span class="keyglyph">\</span><span class="varid">x</span> <span class="varid">r</span> <span class="keyglyph">-&gt;</span> <span class="varid">x</span> <span class="varop">/</span> <span class="layout">(</span><span class="num">1</span> <span class="varop">+</span> <span class="varid">r</span><span class="varop">/</span><span class="num">100</span><span class="layout">)</span><span class="layout">)</span> <span class="layout">(</span><span class="varid">prevSlice</span> <span class="varid">nextSlice</span><span class="layout">)</span> <span class="varid">rateRv</span>
                    <span class="varid">thisSlice</span> <span class="keyglyph">=</span> <span class="varid">zipWith3</span> <span class="layout">(</span><span class="keyglyph">\</span><span class="varid">b</span> <span class="varid">p</span> <span class="varid">q</span> <span class="keyglyph">-&gt;</span> <span class="keyword">if</span> <span class="varid">b</span> <span class="keyword">then</span> <span class="varid">p</span> <span class="keyword">else</span> <span class="varid">q</span><span class="layout">)</span> <span class="comment">-- allow for partially discounted slices</span>
                                  <span class="varid">bRv</span> <span class="varid">pRv</span> <span class="varid">discSlice</span>
                <span class="keyword">in</span> <span class="varid">thisSlice</span> <span class="conop">:</span> <span class="varid">rest</span>
</pre>
prevSlice calculates a previous slice in a lattice by averaging each adjacent pair of values in the specified slice

<pre>       <span class="varid">prevSlice</span> <span class="keyglyph">::</span> <span class="conid">RV</span> <span class="conid">Double</span> <span class="keyglyph">-&gt;</span> <span class="conid">RV</span> <span class="conid">Double</span>
       <span class="varid">prevSlice</span> <span class="conid">[]</span> <span class="keyglyph">=</span> <span class="conid">[]</span>
       <span class="varid">prevSlice</span> <span class="layout">(</span><span class="keyword">_</span><span class="conop">:</span><span class="conid">[]</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="conid">[]</span>
       <span class="varid">prevSlice</span> <span class="layout">(</span><span class="varid">n1</span><span class="conop">:</span><span class="varid">rest</span><span class="keyglyph">@</span><span class="layout">(</span><span class="varid">n2</span><span class="conop">:</span><span class="keyword">_</span><span class="layout">)</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="layout">(</span><span class="varid">n1</span><span class="varop">+</span><span class="varid">n2</span><span class="layout">)</span><span class="varop">/</span><span class="num">2</span> <span class="conop">:</span> <span class="varid">prevSlice</span> <span class="varid">rest</span>
</pre>
<h3 id="exch">'Absorb' primitive</h3>

<p>
"Given a boolean-valued process <code>o</code>, the primitive <code>absorb<sub>k</sub>(o,p)</code> 
transforms the real-valued process <code>p</code>, expressed in currency <code>k</code>, into another
real-valued process. For any state, the result is the expected value of receiving <code>p</code>'s 
value if the region <code>o</code> will never be <code>True</code>, and receiving zero in the contrary.
In states where <code>o</code> is <code>True</code>, the result is therefore zero."
</p>

<pre>   <span class="varid">absorb</span> <span class="keyglyph">::</span> <span class="conid">Currency</span> <span class="keyglyph">-&gt;</span> <span class="layout">(</span><span class="conid">PR</span> <span class="conid">Bool</span><span class="layout">,</span> <span class="conid">PR</span> <span class="conid">Double</span><span class="layout">)</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="conid">Double</span>
   <span class="varid">absorb</span> <span class="varid">k</span> <span class="layout">(</span><span class="conid">PR</span> <span class="varid">bSlices</span><span class="layout">,</span> <span class="conid">PR</span> <span class="varid">rvs</span><span class="layout">)</span> <span class="keyglyph">=</span>
     <span class="conid">PR</span> <span class="varop">$</span> <span class="varid">zipWith</span> <span class="layout">(</span><span class="varid">zipWith</span> <span class="varop">$</span> <span class="keyglyph">\</span><span class="varid">o</span> <span class="varid">p</span> <span class="keyglyph">-&gt;</span> <span class="keyword">if</span> <span class="varid">o</span> <span class="keyword">then</span> <span class="num">0</span> <span class="keyword">else</span> <span class="varid">p</span><span class="layout">)</span>
                  <span class="varid">bSlices</span> <span class="varid">rvs</span>
</pre>
<h3 id="exch">Exchange rate model</h3>

This is a stub which always returns 1.

<pre>   <span class="varid">exch</span> <span class="keyglyph">::</span> <span class="conid">Currency</span> <span class="keyglyph">-&gt;</span> <span class="conid">Currency</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="conid">Double</span>
   <span class="varid">exch</span> <span class="varid">k1</span> <span class="varid">k2</span> <span class="keyglyph">=</span> <span class="conid">PR</span> <span class="layout">(</span><span class="varid">konstSlices</span> <span class="num">1</span><span class="layout">)</span>
</pre>
The definition of the <code>exampleModel</code> ends here.

<h3 id="expected">Expected value</h3>

The code for <code>absorb</code> above does not obviously deal with the expected value mentioned in the spec.  This is because the expected value of each random variable is implicit in the value process lattice representation: each node in the lattice is associated with a <a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#probs">probability</a>, and the expected value at a particular date is simply the sum of the product of the value at each node and its associated probability.  The following functions implement this calculation.

<pre> <span class="varid">expectedValue</span> <span class="keyglyph">::</span> <span class="conid">RV</span> <span class="conid">Double</span> <span class="keyglyph">-&gt;</span> <span class="conid">RV</span> <span class="conid">Double</span> <span class="keyglyph">-&gt;</span> <span class="conid">Double</span>
 <span class="varid">expectedValue</span> <span class="varid">outcomes</span> <span class="varid">probabilities</span> <span class="keyglyph">=</span> <span class="varid">sum</span> <span class="varop">$</span> <span class="varid">zipWith</span> <span class="layout">(</span><span class="varop">*</span><span class="layout">)</span> <span class="varid">outcomes</span> <span class="varid">probabilities</span>
</pre>
<pre> <span class="varid">expectedValuePr</span> <span class="keyglyph">::</span> <span class="conid">PR</span> <span class="conid">Double</span> <span class="keyglyph">-&gt;</span> <span class="keyglyph">[</span><span class="conid">Double</span><span class="keyglyph">]</span>
 <span class="varid">expectedValuePr</span> <span class="layout">(</span><span class="conid">PR</span> <span class="varid">rvs</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">zipWith</span> <span class="varid">expectedValue</span> <span class="varid">rvs</span> <span class="varid">probabilityLattice</span>
</pre>
<h3 id="snell">Snell primitive</h3>

Not currently implemented.  The paper describes the following as a possible algorithm:

<ul>
<li>take the final column of the tree (horizon),
</li><li>discount it back one time step,
</li><li>take the maximum of that column with the corresponding column of the original tree,
</li><li>then repeat that process all the way back to the root.
</li></ul>

<p>
<code>snell<sub>k</sub>(o,p)</code> is the smallest process q (under an ordering relation mention briefly at the end of B:4.6) such that:
</p>

<pre>forall o' . (o =&gt; o') =&gt; q &gt;= snell<sub>k</sub>(o',q)</pre>

<p>
That is, an American option is the least upper bound of any of the deterministic acquisition choices specified by o', where o' is a sub-region of o.
</p>

<h3 id="probs">Probability calculation</h3>

<p>
Each node in a value process lattice is associated with a probability.
</p><p>
"...in our very simple setting the number of paths from the root to the node is proportional to the probability 
that the variable will take that value."
</p>

<pre> <span class="varid">probabilityLattice</span> <span class="keyglyph">::</span> <span class="keyglyph">[</span><span class="conid">RV</span> <span class="conid">Double</span><span class="keyglyph">]</span>
 <span class="varid">probabilityLattice</span> <span class="keyglyph">=</span> <span class="varid">probabilities</span> <span class="varid">pathCounts</span>
   <span class="keyword">where</span>
</pre>
<pre>     <span class="varid">probabilities</span> <span class="keyglyph">::</span> <span class="keyglyph">[</span><span class="conid">RV</span> <span class="conid">Integer</span><span class="keyglyph">]</span> <span class="keyglyph">-&gt;</span> <span class="keyglyph">[</span><span class="conid">RV</span> <span class="conid">Double</span><span class="keyglyph">]</span>
     <span class="varid">probabilities</span> <span class="layout">(</span><span class="varid">sl</span><span class="conop">:</span><span class="varid">sls</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">map</span> <span class="layout">(</span><span class="keyglyph">\</span><span class="varid">n</span> <span class="keyglyph">-&gt;</span> <span class="layout">(</span><span class="varid">fromInteger</span> <span class="varid">n</span><span class="layout">)</span> <span class="varop">/</span> <span class="layout">(</span><span class="varid">fromInteger</span> <span class="layout">(</span><span class="varid">sum</span> <span class="varid">sl</span><span class="layout">)</span><span class="layout">)</span><span class="layout">)</span> <span class="varid">sl</span> <span class="conop">:</span> <span class="varid">probabilities</span> <span class="varid">sls</span>
</pre>
To calculate the number of paths to each node in a lattice, simply add the number of paths to the pair of parent nodes.
This needs to work with Integers as opposed to Ints, because:
<code>findIndex (\sl -&gt; maximum sl &gt; (fromIntegral (maxBound::Int))) pathCounts ==&gt; Just 67</code>

<pre>     <span class="varid">pathCounts</span> <span class="keyglyph">::</span> <span class="keyglyph">[</span><span class="conid">RV</span> <span class="conid">Integer</span><span class="keyglyph">]</span>
     <span class="varid">pathCounts</span> <span class="keyglyph">=</span> <span class="varid">paths</span> <span class="keyglyph">[</span><span class="num">1</span><span class="keyglyph">]</span> <span class="keyword">where</span> <span class="varid">paths</span> <span class="varid">sl</span> <span class="keyglyph">=</span> <span class="varid">sl</span> <span class="conop">:</span> <span class="layout">(</span><span class="varid">paths</span> <span class="layout">(</span><span class="varid">zipWith</span> <span class="layout">(</span><span class="varop">+</span><span class="layout">)</span> <span class="layout">(</span><span class="varid">sl</span><span class="varop">++</span><span class="keyglyph">[</span><span class="num">0</span><span class="keyglyph">]</span><span class="layout">)</span> <span class="layout">(</span><span class="num">0</span><span class="conop">:</span><span class="varid">sl</span><span class="layout">)</span><span class="layout">)</span><span class="layout">)</span>
</pre>
<h2 id="contract-eval">Compositional valuation semantics for contracts</h2>

<p>
See B:Fig.4.  A Haskell type signature for eval is specified in A:5.3.  It has been modified here to return a <code>PR Double</code>, as specified in the semantics in Figure 4, instead of a ValProc.  (In this implementation, the <code>PR Double</code> type is essentially equivalent to the first paper's ValProc type.)
</p>

<pre> <span class="varid">evalC</span> <span class="keyglyph">::</span> <span class="conid">Model</span> <span class="keyglyph">-&gt;</span> <span class="conid">Currency</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="conid">Double</span>
 <span class="varid">evalC</span> <span class="layout">(</span><span class="conid">Model</span> <span class="varid">modelDate</span> <span class="varid">disc</span> <span class="varid">exch</span> <span class="varid">absorb</span> <span class="varid">rateModel</span><span class="layout">)</span> <span class="varid">k</span> <span class="keyglyph">=</span> <span class="varid">eval</span>    <span class="comment">-- punning on record fieldnames for conciseness</span>
   <span class="keyword">where</span> <span class="varid">eval</span> <span class="conid">Zero</span>           <span class="keyglyph">=</span> <span class="varid">bigK</span> <span class="num">0</span>
         <span class="varid">eval</span> <span class="layout">(</span><span class="conid">One</span> <span class="varid">k2</span><span class="layout">)</span>       <span class="keyglyph">=</span> <span class="varid">exch</span> <span class="varid">k</span> <span class="varid">k2</span>
         <span class="varid">eval</span> <span class="layout">(</span><span class="conid">Give</span> <span class="varid">c</span><span class="layout">)</span>       <span class="keyglyph">=</span> <span class="comment">-</span><span class="layout">(</span><span class="varid">eval</span> <span class="varid">c</span><span class="layout">)</span>
         <span class="varid">eval</span> <span class="layout">(</span><span class="varid">o</span> <span class="varop">`Scale`</span> <span class="varid">c</span><span class="layout">)</span>  <span class="keyglyph">=</span> <span class="layout">(</span><span class="varid">evalO</span> <span class="varid">o</span><span class="layout">)</span> <span class="varop">*</span> <span class="layout">(</span><span class="varid">eval</span> <span class="varid">c</span><span class="layout">)</span>
         <span class="varid">eval</span> <span class="layout">(</span><span class="varid">c1</span> <span class="varop">`And`</span> <span class="varid">c2</span><span class="layout">)</span>  <span class="keyglyph">=</span> <span class="layout">(</span><span class="varid">eval</span> <span class="varid">c1</span><span class="layout">)</span> <span class="varop">+</span> <span class="layout">(</span><span class="varid">eval</span> <span class="varid">c2</span><span class="layout">)</span>
         <span class="varid">eval</span> <span class="layout">(</span><span class="varid">c1</span> <span class="varop">`Or`</span> <span class="varid">c2</span><span class="layout">)</span>   <span class="keyglyph">=</span> <span class="varid">max</span> <span class="layout">(</span><span class="varid">eval</span> <span class="varid">c1</span><span class="layout">)</span> <span class="layout">(</span><span class="varid">eval</span> <span class="varid">c2</span><span class="layout">)</span>
         <span class="varid">eval</span> <span class="layout">(</span><span class="conid">Cond</span> <span class="varid">o</span> <span class="varid">c1</span> <span class="varid">c2</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">condPr</span> <span class="layout">(</span><span class="varid">evalO</span> <span class="varid">o</span><span class="layout">)</span> <span class="layout">(</span><span class="varid">eval</span> <span class="varid">c1</span><span class="layout">)</span> <span class="layout">(</span><span class="varid">eval</span> <span class="varid">c2</span><span class="layout">)</span>
         <span class="varid">eval</span> <span class="layout">(</span><span class="conid">When</span> <span class="varid">o</span> <span class="varid">c</span><span class="layout">)</span>     <span class="keyglyph">=</span> <span class="varid">disc</span>   <span class="varid">k</span> <span class="layout">(</span><span class="varid">evalO</span> <span class="varid">o</span><span class="layout">,</span> <span class="varid">eval</span> <span class="varid">c</span><span class="layout">)</span>
 <span class="comment">--      eval (Anytime o c)  = snell  k (evalO o, eval c)</span>
         <span class="varid">eval</span> <span class="layout">(</span><span class="conid">Until</span> <span class="varid">o</span> <span class="varid">c</span><span class="layout">)</span>    <span class="keyglyph">=</span> <span class="varid">absorb</span> <span class="varid">k</span> <span class="layout">(</span><span class="varid">evalO</span> <span class="varid">o</span><span class="layout">,</span> <span class="varid">eval</span> <span class="varid">c</span><span class="layout">)</span>
</pre>
<h2 id="obs-eval">Valuation semantics for observables</h2>

See B:Fig.5.  The evalation function for observables, <code>evalO</code>, converts an observable's function to a value process by applying the function to a start date.

<pre> <span class="varid">evalO</span> <span class="keyglyph">::</span> <span class="conid">Obs</span> <span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varid">a</span>
 <span class="varid">evalO</span> <span class="layout">(</span><span class="conid">Obs</span> <span class="varid">o</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">o</span> <span class="varid">time0</span>
</pre>
<h2 id="process-prims">Process primitives</h2>

B:Fig6

<pre> <span class="varid">bigK</span> <span class="keyglyph">::</span> <span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varid">a</span>
 <span class="varid">bigK</span> <span class="varid">x</span> <span class="keyglyph">=</span> <span class="conid">PR</span> <span class="layout">(</span><span class="varid">konstSlices</span> <span class="varid">x</span><span class="layout">)</span>
</pre>
<pre> <span class="varid">konstSlices</span> <span class="varid">x</span> <span class="keyglyph">=</span> <span class="varid">nextSlice</span> <span class="keyglyph">[</span><span class="varid">x</span><span class="keyglyph">]</span>
   <span class="keyword">where</span> <span class="varid">nextSlice</span> <span class="varid">sl</span> <span class="keyglyph">=</span> <span class="varid">sl</span> <span class="conop">:</span> <span class="layout">(</span><span class="varid">nextSlice</span> <span class="layout">(</span><span class="varid">x</span><span class="conop">:</span><span class="varid">sl</span><span class="layout">)</span><span class="layout">)</span>
</pre>
<pre> <span class="varid">datePr</span> <span class="keyglyph">::</span> <span class="conid">PR</span> <span class="conid">Date</span>
 <span class="varid">datePr</span> <span class="keyglyph">=</span> <span class="conid">PR</span> <span class="varop">$</span> <span class="varid">timeSlices</span> <span class="keyglyph">[</span><span class="varid">time0</span><span class="keyglyph">]</span>
</pre>
<pre> <span class="varid">timeSlices</span> <span class="varid">sl</span><span class="keyglyph">@</span><span class="layout">(</span><span class="layout">(</span><span class="varid">s</span><span class="layout">,</span><span class="varid">t</span><span class="layout">)</span><span class="conop">:</span><span class="keyword">_</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">sl</span> <span class="conop">:</span> <span class="varid">timeSlices</span> <span class="keyglyph">[</span><span class="layout">(</span><span class="varid">s</span><span class="layout">,</span><span class="varid">t</span><span class="varop">+</span><span class="num">1</span><span class="layout">)</span> <span class="keyglyph">|</span> <span class="keyword">_</span> <span class="keyglyph">&lt;-</span> <span class="keyglyph">[</span><span class="num">0</span><span class="keyglyph">..</span><span class="varid">t</span><span class="varop">+</span><span class="num">1</span><span class="keyglyph">]</span><span class="keyglyph">]</span>
</pre>
<pre> <span class="varid">condPr</span> <span class="keyglyph">::</span> <span class="conid">PR</span> <span class="conid">Bool</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varid">a</span>
 <span class="varid">condPr</span> <span class="keyglyph">=</span> <span class="varid">lift3Pr</span> <span class="layout">(</span><span class="keyglyph">\</span><span class="varid">b</span> <span class="varid">tru</span> <span class="varid">fal</span> <span class="keyglyph">-&gt;</span> <span class="keyword">if</span> <span class="varid">b</span> <span class="keyword">then</span> <span class="varid">tru</span> <span class="keyword">else</span> <span class="varid">fal</span><span class="layout">)</span>
</pre>
<pre> <span class="varid">liftPr</span> <span class="keyglyph">::</span> <span class="layout">(</span><span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="varid">b</span><span class="layout">)</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varid">b</span>
 <span class="varid">liftPr</span> <span class="varid">f</span> <span class="layout">(</span><span class="conid">PR</span> <span class="varid">a</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="conid">PR</span> <span class="varop">$</span> <span class="varid">map</span> <span class="layout">(</span><span class="varid">map</span> <span class="varid">f</span><span class="layout">)</span> <span class="varid">a</span>
</pre>
<pre> <span class="varid">lift2Pr</span> <span class="keyglyph">::</span> <span class="layout">(</span><span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="varid">b</span> <span class="keyglyph">-&gt;</span> <span class="varid">c</span><span class="layout">)</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varid">b</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varid">c</span>
 <span class="varid">lift2Pr</span> <span class="varid">f</span> <span class="layout">(</span><span class="conid">PR</span> <span class="varid">a</span><span class="layout">)</span> <span class="layout">(</span><span class="conid">PR</span> <span class="varid">b</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="conid">PR</span> <span class="varop">$</span> <span class="varid">zipWith</span> <span class="layout">(</span><span class="varid">zipWith</span> <span class="varid">f</span><span class="layout">)</span> <span class="varid">a</span> <span class="varid">b</span>
</pre>
<pre> <span class="varid">lift2PrAll</span> <span class="keyglyph">::</span> <span class="layout">(</span><span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="varid">a</span><span class="layout">)</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varid">a</span>
 <span class="varid">lift2PrAll</span> <span class="varid">f</span> <span class="layout">(</span><span class="conid">PR</span> <span class="varid">a</span><span class="layout">)</span> <span class="layout">(</span><span class="conid">PR</span> <span class="varid">b</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="conid">PR</span> <span class="varop">$</span> <span class="varid">zipWithAll</span> <span class="layout">(</span><span class="varid">zipWith</span> <span class="varid">f</span><span class="layout">)</span> <span class="varid">a</span> <span class="varid">b</span>
</pre>
<pre> <span class="varid">lift3Pr</span> <span class="keyglyph">::</span> <span class="layout">(</span><span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="varid">b</span> <span class="keyglyph">-&gt;</span> <span class="varid">c</span> <span class="keyglyph">-&gt;</span> <span class="varid">d</span><span class="layout">)</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varid">b</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varid">c</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="varid">d</span>
 <span class="varid">lift3Pr</span> <span class="varid">f</span> <span class="layout">(</span><span class="conid">PR</span> <span class="varid">a</span><span class="layout">)</span> <span class="layout">(</span><span class="conid">PR</span> <span class="varid">b</span><span class="layout">)</span> <span class="layout">(</span><span class="conid">PR</span> <span class="varid">c</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="conid">PR</span> <span class="varop">$</span> <span class="varid">zipWith3</span> <span class="layout">(</span><span class="varid">zipWith3</span> <span class="varid">f</span><span class="layout">)</span> <span class="varid">a</span> <span class="varid">b</span> <span class="varid">c</span>
</pre>
A version of zipWith that handles input lists of different lengths.  This is used to support lifted binary operations such as (+).

<pre> <span class="varid">zipWithAll</span> <span class="keyglyph">::</span> <span class="layout">(</span><span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="varid">a</span><span class="layout">)</span> <span class="keyglyph">-&gt;</span> <span class="keyglyph">[</span><span class="varid">a</span><span class="keyglyph">]</span> <span class="keyglyph">-&gt;</span> <span class="keyglyph">[</span><span class="varid">a</span><span class="keyglyph">]</span> <span class="keyglyph">-&gt;</span> <span class="keyglyph">[</span><span class="varid">a</span><span class="keyglyph">]</span>
 <span class="varid">zipWithAll</span> <span class="varid">f</span> <span class="layout">(</span><span class="varid">a</span><span class="conop">:</span><span class="keyword">as</span><span class="layout">)</span> <span class="layout">(</span><span class="varid">b</span><span class="conop">:</span><span class="varid">bs</span><span class="layout">)</span>     <span class="keyglyph">=</span> <span class="varid">f</span> <span class="varid">a</span> <span class="varid">b</span> <span class="conop">:</span> <span class="varid">zipWithAll</span> <span class="varid">f</span> <span class="keyword">as</span> <span class="varid">bs</span>
 <span class="varid">zipWithAll</span> <span class="varid">f</span> <span class="keyword">as</span><span class="keyglyph">@</span><span class="layout">(</span><span class="keyword">_</span><span class="conop">:</span><span class="keyword">_</span><span class="layout">)</span> <span class="conid">[]</span>       <span class="keyglyph">=</span> <span class="keyword">as</span>
 <span class="varid">zipWithAll</span> <span class="varid">f</span> <span class="conid">[]</span>       <span class="varid">bs</span><span class="keyglyph">@</span><span class="layout">(</span><span class="keyword">_</span><span class="conop">:</span><span class="keyword">_</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">bs</span>
 <span class="varid">zipWithAll</span> <span class="keyword">_</span> <span class="keyword">_</span>        <span class="keyword">_</span>        <span class="keyglyph">=</span> <span class="conid">[]</span>
</pre>
<pre> <span class="keyword">instance</span> <span class="conid">Num</span> <span class="varid">a</span> <span class="keyglyph">=&gt;</span> <span class="conid">Num</span> <span class="layout">(</span><span class="conid">PR</span> <span class="varid">a</span><span class="layout">)</span> <span class="keyword">where</span>
   <span class="varid">fromInteger</span> <span class="varid">i</span> <span class="keyglyph">=</span> <span class="varid">bigK</span> <span class="layout">(</span><span class="varid">fromInteger</span> <span class="varid">i</span><span class="layout">)</span>
   <span class="layout">(</span><span class="varop">+</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">lift2PrAll</span> <span class="layout">(</span><span class="varop">+</span><span class="layout">)</span>
   <span class="layout">(</span><span class="comment">-</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">lift2PrAll</span> <span class="layout">(</span><span class="comment">-</span><span class="layout">)</span>
   <span class="layout">(</span><span class="varop">*</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">lift2PrAll</span> <span class="layout">(</span><span class="varop">*</span><span class="layout">)</span>
   <span class="varid">abs</span> <span class="keyglyph">=</span> <span class="varid">liftPr</span>  <span class="varid">abs</span>
   <span class="varid">signum</span> <span class="keyglyph">=</span> <span class="varid">liftPr</span> <span class="varid">signum</span>
</pre>
<pre> <span class="keyword">instance</span> <span class="conid">Ord</span> <span class="varid">a</span> <span class="keyglyph">=&gt;</span> <span class="conid">Ord</span> <span class="layout">(</span><span class="conid">PR</span> <span class="varid">a</span><span class="layout">)</span> <span class="keyword">where</span>
   <span class="varid">max</span> <span class="keyglyph">=</span> <span class="varid">lift2Pr</span> <span class="varid">max</span>
</pre>
<pre> <span class="keyword">instance</span> <span class="conid">Eq</span> <span class="varid">a</span> <span class="keyglyph">=&gt;</span> <span class="conid">Eq</span> <span class="layout">(</span><span class="conid">PR</span> <span class="varid">a</span><span class="layout">)</span> <span class="keyword">where</span>
   <span class="layout">(</span><span class="conid">PR</span> <span class="varid">a</span><span class="layout">)</span> <span class="varop">==</span> <span class="layout">(</span><span class="conid">PR</span> <span class="varid">b</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">a</span> <span class="varop">==</span> <span class="varid">b</span>
</pre>

<h2 id="examples">Examples</h2>

Instantiate the example model with what would be the model's starting date, if real dates were used.

<pre> <span class="varid">xm</span> <span class="keyglyph">::</span> <span class="conid">Model</span>
 <span class="varid">xm</span> <span class="keyglyph">=</span> <span class="varid">exampleModel</span> <span class="conid">()</span>
</pre>
Define an evaluator specific to the example model and the USD currency.

<pre> <span class="varid">evalX</span> <span class="keyglyph">::</span> <span class="conid">Contract</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="conid">Double</span>
 <span class="varid">evalX</span> <span class="keyglyph">=</span> <span class="varid">evalC</span> <span class="varid">xm</span> <span class="conid">USD</span>
</pre>
The by-now-infamous zero-coupon bond:

<pre> <span class="varid">zcb</span> <span class="keyglyph">::</span> <span class="conid">Date</span> <span class="keyglyph">-&gt;</span> <span class="conid">Double</span> <span class="keyglyph">-&gt;</span> <span class="conid">Currency</span> <span class="keyglyph">-&gt;</span> <span class="conid">Contract</span>
 <span class="varid">zcb</span> <span class="varid">t</span> <span class="varid">x</span> <span class="varid">k</span> <span class="keyglyph">=</span> <span class="varid">cWhen</span> <span class="layout">(</span><span class="varid">at</span> <span class="varid">t</span><span class="layout">)</span> <span class="layout">(</span><span class="varid">scale</span> <span class="layout">(</span><span class="varid">konst</span> <span class="varid">x</span><span class="layout">)</span> <span class="layout">(</span><span class="varid">one</span> <span class="varid">k</span><span class="layout">)</span><span class="layout">)</span>
</pre>
A contract using the ZCB:

<pre> <span class="varid">c1</span> <span class="keyglyph">::</span> <span class="conid">Contract</span>
 <span class="varid">c1</span> <span class="keyglyph">=</span> <span class="varid">zcb</span> <span class="varid">t1</span> <span class="num">10</span> <span class="conid">USD</span>
</pre>
The test date for the bond is <code>horizon</code> timesteps from the model's current date:

<pre> <span class="varid">t1</span> <span class="keyglyph">::</span> <span class="conid">Date</span>
 <span class="varid">t1</span> <span class="keyglyph">=</span> <span class="varid">mkDate</span> <span class="varid">t1Horizon</span>
</pre>
<pre> <span class="varid">t1Horizon</span> <span class="keyglyph">=</span> <span class="num">3</span> <span class="keyglyph">::</span> <span class="conid">TimeStep</span>
</pre>
A stripped-down versions of the European option from B:3.4.  That example uses real dates that range over more than two years.  This is a smaller version.  Its results have not been checked.

<pre> <span class="varid">c11</span> <span class="keyglyph">::</span> <span class="conid">Contract</span>
 <span class="varid">c11</span> <span class="keyglyph">=</span> <span class="varid">european</span> <span class="layout">(</span><span class="varid">mkDate</span> <span class="num">2</span><span class="layout">)</span>
          <span class="layout">(</span><span class="varid">zcb</span> <span class="layout">(</span><span class="varid">mkDate</span> <span class="num">20</span><span class="layout">)</span> <span class="num">0.4</span> <span class="conid">USD</span> <span class="varop">`cAnd`</span>
           <span class="varid">zcb</span> <span class="layout">(</span><span class="varid">mkDate</span> <span class="num">30</span><span class="layout">)</span> <span class="num">9.3</span> <span class="conid">USD</span> <span class="varop">`cAnd`</span>
           <span class="varid">zcb</span> <span class="layout">(</span><span class="varid">mkDate</span> <span class="num">40</span><span class="layout">)</span> <span class="num">109.3</span> <span class="conid">USD</span> <span class="varop">`cAnd`</span>
           <span class="varid">give</span> <span class="layout">(</span><span class="varid">zcb</span> <span class="layout">(</span><span class="varid">mkDate</span> <span class="num">12</span><span class="layout">)</span> <span class="num">100</span> <span class="conid">USD</span><span class="layout">)</span><span class="layout">)</span>
</pre>
Evaluate the contract c1, in dollars, to produce a value process:

<pre> <span class="varid">pr1</span> <span class="keyglyph">::</span> <span class="conid">PR</span> <span class="conid">Double</span>
 <span class="varid">pr1</span> <span class="keyglyph">=</span> <span class="varid">evalX</span> <span class="varid">c1</span>
</pre>
Access the underlying lattice (list of slices):

<pre> <span class="varid">tr1</span> <span class="keyglyph">=</span> <span class="varid">unPr</span> <span class="varid">pr1</span>
</pre>
Test of 'cUntil' - implementation of absorbEx is similar to zcb, but uses cUntil instead of cWhen.

<pre> <span class="varid">absorbEx</span> <span class="varid">t</span> <span class="varid">x</span> <span class="varid">k</span> <span class="keyglyph">=</span> <span class="varid">cUntil</span> <span class="layout">(</span><span class="varid">konst</span> <span class="varid">t</span> <span class="varop">%&gt;</span> <span class="varid">date</span><span class="layout">)</span> <span class="layout">(</span><span class="varid">scale</span> <span class="layout">(</span><span class="varid">konst</span> <span class="varid">x</span><span class="layout">)</span> <span class="layout">(</span><span class="varid">one</span> <span class="varid">k</span><span class="layout">)</span><span class="layout">)</span>
</pre>

<h3 id="main">Main function</h3>
<p>
There is no main function.  This program is intended to be run in an interactive Haskell environment such as
<a href="http://web.archive.org/web/20130326233424/http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html#ghci-introduction">GHCI</a>, where 
the above examples, combinators, and evaluation functions can be examined and experimented with.  
</p><p>
A <a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/contractEx">web interface</a> to some of the examples is also available.
</p>

<h3 id="pretty">Pretty pictures</h3>

<h4 id="zcb-pic">Process lattice for zcb</h4>
<p>
The following diagram shows the value process lattice for the contract <code>(zcb (mkDate 3) 10 USD)</code>.
It matches B:Fig.9, except for minor details such as the fetching shade of pink.  It was generated using 
<a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#appendixC">GraphViz</a>, by the following code.
</p>

<pre> <span class="varid">zcbImage</span> <span class="keyglyph">=</span> <span class="varid">latticeImage</span> <span class="varid">pr1</span> <span class="str">"fig9"</span> <span class="str">"png"</span>
</pre>
<img src="./Composing Contracts_files/fig9.png">
<p></p><p>

</p><h4 id="expected-chart">Expected value</h4>

The following is a chart of expected value at each timestep.  The implementation uses the Google Chart API.
<p></p>

<pre> <span class="varid">c1ExpectedValueUrl</span> <span class="keyglyph">=</span> <span class="varid">chartUrl</span> <span class="varop">$</span> <span class="varid">expectedValuePr</span> <span class="varid">pr1</span>
</pre>
<!-- the following URL was generated by the above code and pasted here -->
<img src="./Composing Contracts_files/chart">
<p></p>

<h4 id="ratechart">Interest rate evolution</h4>

This is the short-term interest rate evolution from B:Fig8.

<pre> <span class="varid">rateEvolution</span> <span class="keyglyph">=</span> <span class="varid">latticeImage</span> <span class="layout">(</span><span class="varid">takePr</span> <span class="layout">(</span><span class="varid">t1Horizon</span> <span class="varop">+</span> <span class="num">1</span><span class="layout">)</span> <span class="varop">$</span> <span class="varid">rateModel</span> <span class="varid">xm</span> <span class="conid">USD</span><span class="layout">)</span> <span class="str">"fig8"</span> <span class="str">"png"</span>
</pre>
<img src="./Composing Contracts_files/fig8.png">


<h2 id="todo">Future work</h2>

In its present state, this implementation is very much a prototype, intended mainly to provide a concrete illustration of concepts described in the papers on which it is based.  The core implementation is less than 200 lines of Haskell code, excluding examples and user interface.  As such, it has many limitations and omissions.  Some of the more obvious enhancements that could be made include:

<ul>
<li>Support actual dates and times.
</li><li>Implement monadic contract evaluator.
</li><li>Enhance observable representation.
</li><li>Improve contract horizon handling.
</li><li>Implement more realistic interest and exchange rate models.
</li><li>Implement the snell function.
</li><li>Implement a model using other kinds of numerical methods, such as Monte Carlo.
</li><li>Implement models for specific observables.
</li><li>Factoring into modules.
</li></ul>

Additional detail for selected items follows.

<h3 id="time-handling">Support actual dates and times</h3>
<p>
As described in <a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#basictypes">Basic data types</a>, time is currently modeled using abstract integer time steps. Adding basic support for real dates and times should not be difficult.  Since many financial contracts do not need to be concerned with time steps smaller than days, the following description will focus only on date handling, but the same design applies to support for real times.
</p><p>
Adding date support requires changes in the following areas:
</p>
<ul>
<li>Value processes should store their start date in order to correctly handle operations involving processes that start at different dates.

</li><li>Operations on value processes need to check the start dates of the processes they operate on, and proceed accordingly.  For example, when adding two value processes that begin at different dates, only random variables which represent the same time step should be added together.

</li><li>Functions that rely on the zeroth time step <code>time0</code>, particularly the observable evalution function <code>evalO</code> and the date process <code>datePr</code>, should instead use the start date of the contract evaluator's <code>Model</code> parameter.  This can be achieved by converting the contract evaluator <code>evalC</code> from direct style to monadic style (see next subsection), which will allow the functions in question access to the model's start date.
</li></ul>

<h3 id="evalarch">Implement monadic contract evaluator</h3>
<p>
The evaluator for contracts is currently a very simple, direct-style implementation.  This is possible in part because of simplifying choices such as the use of time steps without actual dates, as mentioned above.
</p><p>
Many other kinds of enhancements to the implementation are likely to require a more sophisticated evaluator design.  Converting to a monadic evaluator would support such enhancements.  Aside from providing primitives direct access to the model, it would also allow alternate monads and monad transformers to be used to parameterize the evaluator semantics.  Jeff Polakow pointed out that a probability monad could be useful, for example.
</p>

<h3 id="obs-rep">Enhance observable representation</h3>

Two ways in which the representation of observables might be enhanced are as follows:

<ul>
<li>C:4.1 suggests that the type could be designed to support simplification and other changes to the observable over time, as well as efficient handling of time intervals (C:4.2).  The details here depend on the requirements of the system being developed.

</li><li>As the definition of the <code>Show</code> instance for the <a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#obs">Observable data type</a> demonstrates, the representation of observables as functions limits the ability to inspect contract definitions. With an embedded DSL, if metadata is not stored along with the DSL terms, then the host language source code may be the only complete specification of embedded terms that involve functions.  This could be addressed by the use of a tag to identify observables.  This might take the form of a sum type representing primitive observables such as constants and dates, with provision for arbitrary named functions for more complex observables.  Such a representation is hinted at in the description of the valuation semantics for observables in B:Fig.5.
</li></ul>

<h3 id="horizon-support">Improve contract horizon handling</h3>
<p>
The second paper's use of boolean value processes to represent acquisition regions is very general.  The full generality of this model is not exploited by the current implementation.  For example, the <a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/#disc">disc primitive</a> assumes that the horizon of a contract corresponds to a single random variable.  However, contract horizons may be based on more complex observables than the date, and composed contracts may also result in complex scenarios in which a contract's horizon crosses more than one random variable.
</p><p>
In addition, some value processes are infinite and have no horizons.  The system should track this to allow it to prevent attempts to perform non-terminating operations on such contracts.  This may also help in implementing operations that combine contracts with different horizons.
</p>

<h2 id="appendixA">Appendix A - Tests</h2>

<p>
A few small tests that came up during development.
</p><p>

</p><pre> <span class="varid">tolerance</span> <span class="keyglyph">=</span> <span class="num">0.001</span>
</pre>
Test of constant process:

<pre> <span class="varid">testK</span> <span class="keyglyph">=</span> <span class="varid">andPr</span> <span class="varop">$</span> <span class="varid">liftPr</span> <span class="layout">(</span><span class="varop">==</span> <span class="num">100</span><span class="layout">)</span> <span class="varop">$</span> <span class="varid">takePr</span> <span class="num">10</span> <span class="layout">(</span><span class="varid">bigK</span> <span class="num">100</span><span class="layout">)</span>
</pre>
Test that a slice in the probability lattice adds up to probability 1.0:

<pre> <span class="varid">testProb</span> <span class="keyglyph">=</span> <span class="layout">(</span><span class="varid">sum</span> <span class="varop">$</span> <span class="varid">probabilityLattice</span> <span class="varop">!!</span> <span class="num">100</span><span class="layout">)</span> <span class="comment">-</span> <span class="num">1</span> <span class="varop">&lt;</span> <span class="varid">tolerance</span>
</pre>
Test the result of evaluating the c1 contract

<pre> <span class="varid">testPr1</span> <span class="keyglyph">=</span> <span class="varid">andPr</span> <span class="varop">$</span> <span class="varid">lift2Pr</span> <span class="layout">(</span><span class="keyglyph">\</span><span class="varid">a</span> <span class="varid">b</span> <span class="keyglyph">-&gt;</span> <span class="layout">(</span><span class="varid">abs</span> <span class="layout">(</span><span class="varid">a</span> <span class="comment">-</span> <span class="varid">b</span><span class="layout">)</span><span class="layout">)</span> <span class="varop">&lt;</span> <span class="varid">tolerance</span><span class="layout">)</span>
                           <span class="varid">pr1</span>
                           <span class="layout">(</span><span class="conid">PR</span> <span class="keyglyph">[</span><span class="keyglyph">[</span><span class="num">8.641</span><span class="keyglyph">]</span><span class="layout">,</span> <span class="keyglyph">[</span><span class="num">9.246</span><span class="layout">,</span><span class="num">8.901</span><span class="keyglyph">]</span><span class="layout">,</span> <span class="keyglyph">[</span><span class="num">9.709</span><span class="layout">,</span><span class="num">9.524</span><span class="layout">,</span><span class="num">9.346</span><span class="keyglyph">]</span><span class="layout">,</span> <span class="keyglyph">[</span><span class="num">10</span><span class="layout">,</span><span class="num">10</span><span class="layout">,</span><span class="num">10</span><span class="layout">,</span><span class="num">10</span><span class="keyglyph">]</span><span class="keyglyph">]</span><span class="layout">)</span>
</pre>
Run all tests (all three of them!)

<pre> <span class="varid">tests</span> <span class="keyglyph">=</span> <span class="varid">and</span> <span class="keyglyph">[</span><span class="varid">testK</span>
             <span class="layout">,</span><span class="varid">testProb</span>
             <span class="layout">,</span><span class="varid">testPr1</span><span class="keyglyph">]</span>
</pre>

<h2 id="appendixB">Appendix B - HTML table output for value process</h2>

This renders a value process lattice as a kind of pyramid, using an HTML table.

<pre> <span class="varid">prToTable</span> <span class="varid">pr</span><span class="keyglyph">@</span><span class="layout">(</span><span class="conid">PR</span> <span class="varid">rvs</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">table</span> <span class="varop">&lt;&lt;</span> <span class="layout">(</span><span class="varid">snd</span> <span class="varop">$</span> <span class="varid">foldl</span> <span class="varid">renderSlice</span> <span class="layout">(</span><span class="num">0</span><span class="layout">,</span> <span class="varid">noHtml</span><span class="layout">)</span> <span class="varid">rvs</span><span class="layout">)</span>
   <span class="keyword">where</span>
</pre>
<pre>     <span class="varid">horizon</span> <span class="keyglyph">=</span> <span class="varid">horizonPr</span> <span class="varid">pr</span>
     <span class="varid">renderSlice</span> <span class="layout">(</span><span class="varid">n</span><span class="layout">,</span> <span class="varid">rows</span><span class="layout">)</span> <span class="varid">rv</span> <span class="keyglyph">=</span> <span class="layout">(</span><span class="varid">n</span><span class="varop">+</span><span class="num">1</span><span class="layout">,</span> <span class="varid">rows</span> <span class="varop">+++</span> <span class="layout">(</span><span class="varid">tr</span> <span class="varop">$</span> <span class="varid">td</span> <span class="varop">&lt;&lt;</span> <span class="layout">(</span><span class="varid">show</span> <span class="varid">n</span><span class="layout">)</span>
                                                   <span class="varop">+++</span> <span class="layout">(</span><span class="varid">spacer</span> <span class="varop">$</span> <span class="varid">horizon</span> <span class="comment">-</span> <span class="varid">n</span><span class="layout">)</span>
                                                   <span class="varop">+++</span> <span class="layout">(</span><span class="varid">concatHtml</span> <span class="layout">(</span><span class="varid">map</span> <span class="varid">renderCell</span> <span class="varid">rv</span><span class="layout">)</span><span class="layout">)</span>
                                                   <span class="varop">+++</span> <span class="layout">(</span><span class="varid">spacer</span> <span class="varop">$</span> <span class="varid">horizon</span> <span class="comment">-</span> <span class="varid">n</span> <span class="varop">+</span> <span class="num">1</span><span class="layout">)</span><span class="layout">)</span><span class="layout">)</span>
</pre>
<pre>     <span class="varid">renderCell</span> <span class="varid">v</span> <span class="keyglyph">=</span> <span class="varid">td</span> <span class="varop">!</span> <span class="keyglyph">[</span><span class="varid">theclass</span> <span class="str">"cell"</span><span class="layout">,</span> <span class="varid">colspan</span> <span class="num">2</span><span class="keyglyph">]</span> <span class="varop">&lt;&lt;</span> <span class="layout">(</span><span class="varid">showFFloat</span> <span class="layout">(</span><span class="conid">Just</span> <span class="num">2</span><span class="layout">)</span> <span class="varid">v</span> <span class="str">""</span><span class="layout">)</span>
</pre>
<pre> <span class="varid">spacer</span> <span class="num">0</span> <span class="keyglyph">=</span> <span class="varid">noHtml</span>
 <span class="varid">spacer</span> <span class="varid">n</span> <span class="keyglyph">=</span> <span class="varid">td</span> <span class="varop">!</span> <span class="keyglyph">[</span><span class="varid">theclass</span> <span class="str">"sp"</span><span class="layout">,</span> <span class="varid">colspan</span> <span class="varid">n</span><span class="keyglyph">]</span> <span class="varop">&lt;&lt;</span> <span class="varid">noHtml</span>
</pre>
<h2 id="appendixC">Appendix C - Graphviz Output</h2>

<p>
This code generates graphs which represent a value process lattice.  Currently assumes Double values, constrained by showNode's formatting of the value.
</p><p>
Write out tree as Dot file and run Dot to generate image:
</p>

<pre> <span class="varid">latticeImage</span> <span class="keyglyph">::</span> <span class="conid">PR</span> <span class="conid">Double</span> <span class="keyglyph">-&gt;</span> <span class="conid">String</span> <span class="keyglyph">-&gt;</span> <span class="conid">String</span> <span class="keyglyph">-&gt;</span> <span class="conid">IO</span> <span class="conid">ExitCode</span>
 <span class="varid">latticeImage</span> <span class="varid">pr</span> <span class="varid">baseName</span> <span class="varid">imageType</span> <span class="keyglyph">=</span>
   <span class="keyword">do</span> <span class="varid">writeTreeAsDot</span> <span class="varid">baseName</span> <span class="varid">pr</span>
      <span class="varid">runDot</span> <span class="varid">baseName</span> <span class="varid">imageType</span>
</pre>
Supports interactive display of generated Dot code.

<pre> <span class="varid">printTree</span> <span class="keyglyph">::</span> <span class="conid">PR</span> <span class="conid">Double</span> <span class="keyglyph">-&gt;</span> <span class="conid">IO</span> <span class="conid">()</span>
 <span class="varid">printTree</span> <span class="varid">pr</span> <span class="keyglyph">=</span> <span class="varid">mapM_</span> <span class="varid">putStrLn</span> <span class="layout">(</span><span class="varid">dotGraph</span> <span class="layout">(</span><span class="varid">prToDot</span> <span class="varid">pr</span><span class="layout">)</span><span class="layout">)</span>
</pre>
Write a value process out as a Dot file.

<pre> <span class="varid">writeTreeAsDot</span> <span class="keyglyph">::</span> <span class="conid">String</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="conid">Double</span> <span class="keyglyph">-&gt;</span> <span class="conid">IO</span> <span class="conid">()</span>
 <span class="varid">writeTreeAsDot</span> <span class="varid">baseName</span> <span class="varid">pr</span> <span class="keyglyph">=</span> <span class="varid">writeFile</span> <span class="layout">(</span><span class="varid">baseName</span> <span class="varop">++</span> <span class="varid">dotExt</span><span class="layout">)</span> <span class="varop">$</span> <span class="varid">unlines</span> <span class="layout">(</span><span class="varid">dotGraph</span> <span class="layout">(</span><span class="varid">prToDot</span> <span class="varid">pr</span><span class="layout">)</span><span class="layout">)</span>
</pre>
Run Dot on a file with the specified base name, and generate a graphic file with the specified type.

<pre> <span class="varid">runDot</span> <span class="keyglyph">::</span> <span class="conid">String</span> <span class="keyglyph">-&gt;</span> <span class="conid">String</span> <span class="keyglyph">-&gt;</span> <span class="conid">IO</span> <span class="conid">ExitCode</span>
 <span class="varid">runDot</span> <span class="varid">baseName</span> <span class="varid">fileType</span> <span class="keyglyph">=</span>
   <span class="varid">system</span> <span class="varop">$</span> <span class="varid">concat</span> <span class="keyglyph">[</span><span class="str">"dot -T"</span><span class="layout">,</span> <span class="varid">fileType</span><span class="layout">,</span>
                    <span class="str">" -o "</span><span class="layout">,</span> <span class="varid">baseName</span><span class="layout">,</span> <span class="str">"."</span><span class="layout">,</span> <span class="varid">fileType</span><span class="layout">,</span> <span class="str">" "</span><span class="layout">,</span>
                    <span class="varid">baseName</span><span class="layout">,</span> <span class="varid">dotExt</span><span class="keyglyph">]</span>
</pre>
Convert a (PR Double) to a list of dot node relationships.

<pre> <span class="varid">prToDot</span> <span class="keyglyph">::</span> <span class="conid">PR</span> <span class="conid">Double</span> <span class="keyglyph">-&gt;</span> <span class="keyglyph">[</span><span class="conid">String</span><span class="keyglyph">]</span>
 <span class="varid">prToDot</span> <span class="layout">(</span><span class="conid">PR</span> <span class="varid">rvs</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">rvsToDot</span> <span class="varid">rvs</span>
</pre>
Convert lattice to list of dot node relationships.

<pre> <span class="varid">rvsToDot</span> <span class="keyglyph">::</span> <span class="keyglyph">[</span><span class="conid">RV</span> <span class="conid">Double</span><span class="keyglyph">]</span> <span class="keyglyph">-&gt;</span> <span class="keyglyph">[</span><span class="conid">String</span><span class="keyglyph">]</span>
 <span class="varid">rvsToDot</span> <span class="varid">rvs</span> <span class="keyglyph">=</span> <span class="keyword">let</span> <span class="varid">numberedRvs</span> <span class="keyglyph">=</span> <span class="varid">assignIds</span> <span class="varid">rvs</span> <span class="num">1</span>
                <span class="keyword">in</span> <span class="varid">showNodes</span> <span class="varid">numberedRvs</span> <span class="varop">++</span> <span class="varid">treeToDot</span> <span class="varid">numberedRvs</span>
</pre>
<pre> <span class="varid">dotExt</span> <span class="keyglyph">=</span> <span class="str">".dot"</span>
</pre>
Number each of the nodes in a lattice.

<pre> <span class="varid">assignIds</span> <span class="keyglyph">::</span> <span class="keyglyph">[</span><span class="conid">RV</span> <span class="varid">a</span><span class="keyglyph">]</span> <span class="keyglyph">-&gt;</span> <span class="conid">Int</span> <span class="keyglyph">-&gt;</span> <span class="keyglyph">[</span><span class="conid">RV</span> <span class="layout">(</span><span class="conid">Int</span><span class="layout">,</span> <span class="varid">a</span><span class="layout">)</span><span class="keyglyph">]</span>
 <span class="varid">assignIds</span> <span class="conid">[]</span> <span class="varid">n</span> <span class="keyglyph">=</span> <span class="conid">[]</span>
 <span class="varid">assignIds</span> <span class="layout">(</span><span class="varid">rv</span><span class="conop">:</span><span class="varid">rvs</span><span class="layout">)</span> <span class="varid">n</span> <span class="keyglyph">=</span> <span class="varid">numberList</span> <span class="layout">(</span><span class="varid">reverse</span> <span class="varid">rv</span><span class="layout">)</span> <span class="varid">n</span> <span class="conop">:</span> <span class="varid">assignIds</span> <span class="varid">rvs</span> <span class="layout">(</span><span class="varid">n</span> <span class="varop">+</span> <span class="varid">length</span> <span class="varid">rv</span><span class="layout">)</span>
</pre>
<pre> <span class="varid">numberList</span> <span class="keyglyph">::</span> <span class="keyglyph">[</span><span class="varid">a</span><span class="keyglyph">]</span> <span class="keyglyph">-&gt;</span> <span class="conid">Int</span> <span class="keyglyph">-&gt;</span> <span class="keyglyph">[</span><span class="layout">(</span><span class="conid">Int</span><span class="layout">,</span> <span class="varid">a</span><span class="layout">)</span><span class="keyglyph">]</span>
 <span class="varid">numberList</span> <span class="varid">l</span> <span class="varid">n</span> <span class="keyglyph">=</span> <span class="varid">zip</span> <span class="keyglyph">[</span><span class="varid">n</span> <span class="keyglyph">..</span> <span class="varid">n</span> <span class="varop">+</span> <span class="varid">length</span> <span class="varid">l</span><span class="keyglyph">]</span> <span class="varid">l</span>
</pre>
showNodes returns a list of "primary" Dot representations of numbered RV nodes, with
each node's value specified as the node's label.  These nodes can then be referenced
repeatedly in the generated Dot code without specifying a label.

<pre> <span class="varid">showNodes</span> <span class="keyglyph">::</span> <span class="keyglyph">[</span><span class="conid">RV</span> <span class="layout">(</span><span class="conid">Int</span><span class="layout">,</span> <span class="conid">Double</span><span class="layout">)</span><span class="keyglyph">]</span> <span class="keyglyph">-&gt;</span> <span class="keyglyph">[</span><span class="conid">String</span><span class="keyglyph">]</span>
 <span class="varid">showNodes</span> <span class="varid">numberedRvs</span> <span class="keyglyph">=</span> <span class="varid">concatMap</span> <span class="varid">showSlice</span> <span class="layout">(</span><span class="varid">numberList</span> <span class="varid">numberedRvs</span> <span class="num">0</span><span class="layout">)</span>
   <span class="keyword">where</span> <span class="varid">showSlice</span> <span class="layout">(</span><span class="varid">n</span><span class="layout">,</span> <span class="varid">sl</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="layout">(</span><span class="str">"subgraph Slice"</span> <span class="varop">++</span> <span class="varid">show</span> <span class="varid">n</span> <span class="varop">++</span> <span class="str">" { rank=same"</span><span class="layout">)</span>
                             <span class="conop">:</span> <span class="layout">(</span><span class="varid">map</span> <span class="layout">(</span><span class="keyglyph">\</span><span class="layout">(</span><span class="varid">n</span><span class="layout">,</span><span class="varid">s</span><span class="layout">)</span> <span class="keyglyph">-&gt;</span> <span class="varid">show</span> <span class="varid">n</span> <span class="varop">++</span> <span class="varid">nodeLabel</span> <span class="varid">s</span><span class="layout">)</span> <span class="varid">sl</span><span class="layout">)</span>
                             <span class="varop">++</span> <span class="keyglyph">[</span><span class="str">"SL"</span> <span class="varop">++</span> <span class="layout">(</span><span class="varid">show</span> <span class="varid">n</span><span class="layout">)</span> <span class="varop">++</span> <span class="str">" [label=\""</span> <span class="varop">++</span> <span class="varid">show</span> <span class="varid">n</span> <span class="varop">++</span> <span class="str">"\" style=solid peripheries=0] }"</span><span class="keyglyph">]</span>
</pre>
<pre> <span class="varid">nodeLabel</span> <span class="keyglyph">::</span> <span class="conid">Double</span> <span class="keyglyph">-&gt;</span> <span class="conid">String</span>
 <span class="varid">nodeLabel</span> <span class="varid">s</span> <span class="keyglyph">=</span> <span class="str">" [label=\""</span> <span class="varop">++</span> <span class="layout">(</span><span class="varid">showFFloat</span> <span class="layout">(</span><span class="conid">Just</span> <span class="num">2</span><span class="layout">)</span> <span class="varid">s</span> <span class="str">"\"]"</span><span class="layout">)</span>
</pre>
generate Dot code for relationships between numbered RV nodes.

<pre> <span class="varid">treeToDot</span> <span class="keyglyph">::</span> <span class="keyglyph">[</span><span class="conid">RV</span> <span class="layout">(</span><span class="conid">Int</span><span class="layout">,</span> <span class="varid">a</span><span class="layout">)</span><span class="keyglyph">]</span> <span class="keyglyph">-&gt;</span> <span class="keyglyph">[</span><span class="conid">String</span><span class="keyglyph">]</span>
 <span class="varid">treeToDot</span> <span class="keyglyph">[</span><span class="varid">a</span><span class="keyglyph">]</span> <span class="keyglyph">=</span> <span class="conid">[]</span>
 <span class="varid">treeToDot</span> <span class="layout">(</span><span class="varid">a</span><span class="conop">:</span><span class="varid">b</span><span class="conop">:</span><span class="varid">rest</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">dotJoin</span> <span class="varid">a</span> <span class="layout">(</span><span class="varid">take</span> <span class="layout">(</span><span class="varid">length</span> <span class="varid">a</span><span class="layout">)</span> <span class="varid">b</span><span class="layout">)</span>
                     <span class="varop">++</span> <span class="varid">dotJoin</span> <span class="varid">a</span> <span class="layout">(</span><span class="varid">tail</span> <span class="varid">b</span><span class="layout">)</span>
                     <span class="varop">++</span> <span class="varid">treeToDot</span> <span class="layout">(</span><span class="varid">b</span><span class="conop">:</span><span class="varid">rest</span><span class="layout">)</span>
</pre>
<pre> <span class="varid">dotJoin</span> <span class="keyglyph">::</span> <span class="conid">RV</span> <span class="layout">(</span><span class="conid">Int</span><span class="layout">,</span> <span class="varid">a</span><span class="layout">)</span> <span class="keyglyph">-&gt;</span> <span class="conid">RV</span> <span class="layout">(</span><span class="conid">Int</span><span class="layout">,</span> <span class="varid">a</span><span class="layout">)</span> <span class="keyglyph">-&gt;</span> <span class="keyglyph">[</span><span class="conid">String</span><span class="keyglyph">]</span>
 <span class="varid">dotJoin</span> <span class="varid">a</span> <span class="varid">b</span> <span class="keyglyph">=</span> <span class="varid">zipWith</span> <span class="layout">(</span><span class="keyglyph">\</span><span class="layout">(</span><span class="varid">m</span><span class="layout">,</span><span class="varid">a</span><span class="layout">)</span> <span class="layout">(</span><span class="varid">n</span><span class="layout">,</span><span class="varid">b</span><span class="layout">)</span> <span class="keyglyph">-&gt;</span> <span class="layout">(</span><span class="varid">show</span> <span class="varid">m</span><span class="layout">)</span> <span class="varop">++</span> <span class="str">" -- "</span> <span class="varop">++</span> <span class="layout">(</span><span class="varid">show</span> <span class="varid">n</span><span class="layout">)</span><span class="layout">)</span> <span class="varid">a</span> <span class="varid">b</span>
</pre>


<pre> <span class="varid">dotGraph</span> <span class="keyglyph">::</span> <span class="keyglyph">[</span><span class="conid">String</span><span class="keyglyph">]</span> <span class="keyglyph">-&gt;</span> <span class="keyglyph">[</span><span class="conid">String</span><span class="keyglyph">]</span>
 <span class="varid">dotGraph</span> <span class="varid">body</span> <span class="keyglyph">=</span> <span class="varid">dotGraphHdr</span> <span class="varop">++</span> <span class="layout">(</span><span class="varid">map</span> <span class="varid">formatDotStmt</span> <span class="varid">body</span><span class="layout">)</span> <span class="varop">++</span> <span class="keyglyph">[</span><span class="str">"}"</span><span class="keyglyph">]</span>
</pre>
<pre> <span class="varid">dotGraphHdr</span> <span class="keyglyph">::</span> <span class="keyglyph">[</span><span class="conid">String</span><span class="keyglyph">]</span>
 <span class="varid">dotGraphHdr</span> <span class="keyglyph">=</span> <span class="keyglyph">[</span><span class="str">"graph contract_lattice {"</span>
                 <span class="layout">,</span><span class="str">"  rankdir=LR;"</span>
                 <span class="layout">,</span><span class="str">"  dir=none;"</span>
                 <span class="layout">,</span><span class="str">"  node [style=filled color=pink shape=box fontsize=10 width=0.5 height=0.4];"</span><span class="keyglyph">]</span>
</pre>
<pre> <span class="varid">formatDotStmt</span> <span class="keyglyph">::</span> <span class="conid">String</span> <span class="keyglyph">-&gt;</span> <span class="conid">String</span>
 <span class="varid">formatDotStmt</span> <span class="varid">s</span> <span class="keyglyph">=</span> <span class="str">"  "</span> <span class="varop">++</span> <span class="varid">s</span> <span class="varop">++</span> <span class="str">";"</span>
</pre>

<h2 id="appendixD">Appendix D - Google chart</h2>

This generates a URL for the Google Chart API.  Used for expected value chart.

<pre> <span class="varid">chartUrl</span> <span class="keyglyph">::</span> <span class="keyglyph">[</span><span class="conid">Double</span><span class="keyglyph">]</span> <span class="keyglyph">-&gt;</span> <span class="conid">String</span>
 <span class="varid">chartUrl</span> <span class="varid">vs</span> <span class="keyglyph">=</span> <span class="str">"http://chart.apis.google.com/chart?chs=300x200&amp;cht=lc&amp;chxt=x,y&amp;chg=20,25,2,5&amp;chxr=0,0,"</span>
               <span class="varop">++</span> <span class="layout">(</span><span class="varid">show</span> <span class="varop">$</span> <span class="varid">length</span> <span class="varid">vs</span> <span class="comment">-</span> <span class="num">1</span><span class="layout">)</span>
               <span class="varop">++</span> <span class="str">"|1,"</span> <span class="varop">++</span> <span class="layout">(</span><span class="varid">showFFloat</span> <span class="layout">(</span><span class="conid">Just</span> <span class="num">1</span><span class="layout">)</span> <span class="varid">ymin</span> <span class="str">","</span><span class="layout">)</span>
                        <span class="varop">++</span> <span class="layout">(</span><span class="varid">showFFloat</span> <span class="layout">(</span><span class="conid">Just</span> <span class="num">1</span><span class="layout">)</span> <span class="varid">ymax</span> <span class="str">"&amp;chd=t:"</span><span class="layout">)</span>
               <span class="varop">++</span> <span class="layout">(</span><span class="varid">concat</span> <span class="varop">$</span> <span class="varid">intersperse</span> <span class="str">","</span> <span class="varop">$</span> <span class="varid">map</span> <span class="layout">(</span><span class="keyglyph">\</span><span class="varid">y</span> <span class="keyglyph">-&gt;</span> <span class="varid">showFFloat</span> <span class="layout">(</span><span class="conid">Just</span> <span class="num">1</span><span class="layout">)</span> <span class="varid">y</span> <span class="str">""</span><span class="layout">)</span> <span class="varid">ys</span><span class="layout">)</span>
   <span class="keyword">where</span> <span class="layout">(</span><span class="varid">ymin</span><span class="layout">,</span> <span class="varid">ymax</span><span class="layout">,</span> <span class="varid">ys</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">chartScale</span> <span class="varid">vs</span> <span class="num">100</span>
</pre>
Scale specified list of values to a range between 0 and <code>upper</code>.

<pre> <span class="varid">chartScale</span> <span class="varid">ys</span> <span class="varid">upper</span> <span class="keyglyph">=</span>
   <span class="keyword">let</span> <span class="varid">ymin</span> <span class="keyglyph">=</span> <span class="varid">minimum</span> <span class="varid">ys</span>
       <span class="varid">ymax</span> <span class="keyglyph">=</span> <span class="varid">maximum</span> <span class="varid">ys</span>
       <span class="varid">yrange</span> <span class="keyglyph">=</span> <span class="varid">ymax</span> <span class="comment">-</span> <span class="varid">ymin</span>
       <span class="varid">yscale</span> <span class="keyglyph">=</span> <span class="varid">upper</span><span class="varop">/</span><span class="varid">yrange</span>
   <span class="keyword">in</span> <span class="layout">(</span><span class="varid">ymin</span><span class="layout">,</span> <span class="varid">ymax</span><span class="layout">,</span> <span class="varid">map</span> <span class="layout">(</span><span class="keyglyph">\</span><span class="varid">y</span> <span class="keyglyph">-&gt;</span> <span class="layout">(</span><span class="varid">y</span> <span class="comment">-</span> <span class="varid">ymin</span><span class="layout">)</span> <span class="varop">*</span> <span class="varid">yscale</span> <span class="layout">)</span> <span class="varid">ys</span><span class="layout">)</span>
</pre>

<h2 id="appendixE">Appendix E - Web interface</h2>
<p>
The following code implements a very simple web interface, which allows a few canned examples to be run and displays the resulting value process lattice images along with a chart of expected value (where appropriate).
</p><p>
At the time of writing, the web interface is running at <a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/contractEx">http://contracts.scheming.org/contractEx</a>.  This URL may change in future.
</p>

<h3 id="ExContr">Serializable example specification</h3>

ExContr is a type to specify examples to be run, which is serialized in the request URL.

<pre> <span class="keyword">newtype</span> <span class="conid">ExContr</span> <span class="keyglyph">=</span> <span class="conid">ExContr</span> <span class="layout">(</span><span class="conid">String</span><span class="layout">,</span> <span class="keyglyph">[</span><span class="conid">Double</span><span class="keyglyph">]</span><span class="layout">,</span> <span class="conid">Bool</span><span class="layout">)</span> <span class="keyword">deriving</span> <span class="layout">(</span><span class="conid">Read</span><span class="layout">,</span><span class="conid">Show</span><span class="layout">,</span><span class="conid">Eq</span><span class="layout">)</span>
</pre>
<pre> <span class="varid">useLatticeImage</span> <span class="layout">(</span><span class="conid">ExContr</span> <span class="layout">(</span><span class="keyword">_</span><span class="layout">,</span> <span class="keyword">_</span><span class="layout">,</span> <span class="varid">b</span><span class="layout">)</span><span class="layout">)</span> <span class="keyglyph">=</span> <span class="varid">b</span>

 <span class="varid">webPath</span> <span class="keyglyph">=</span> <span class="str">"/home/anton/usr/happs.org/public/"</span>
 <span class="comment">-- webPath = "/home/anton/happs91/HAppS-Begin/public/"</span>

 <span class="varid">tmpImgPath</span> <span class="keyglyph">=</span> <span class="str">"imgtmp/"</span>

 <span class="varid">baseDotFilename</span> <span class="keyglyph">=</span> <span class="str">"pr-lattice"</span>

 <span class="varid">pageTitle</span> <span class="keyglyph">=</span> <span class="str">"Composing contracts - simple charts"</span>
</pre>
<pre> <span class="varid">mkUniqueName</span> <span class="keyglyph">::</span> <span class="conid">String</span> <span class="keyglyph">-&gt;</span> <span class="conid">IO</span> <span class="conid">String</span>
 <span class="varid">mkUniqueName</span> <span class="varid">baseName</span> <span class="keyglyph">=</span>
   <span class="keyword">do</span> <span class="varid">u</span> <span class="keyglyph">&lt;-</span> <span class="varid">newUnique</span>
      <span class="varid">return</span> <span class="varop">$</span> <span class="varid">baseName</span> <span class="varop">++</span> <span class="layout">(</span><span class="varid">show</span> <span class="varop">$</span> <span class="varid">hashUnique</span> <span class="varid">u</span><span class="layout">)</span>
</pre>
<pre> <span class="varid">renderEx</span> <span class="keyglyph">::</span> <span class="conid">ExContr</span> <span class="keyglyph">-&gt;</span> <span class="conid">IO</span> <span class="conid">Html</span>
 <span class="varid">renderEx</span> <span class="varid">exSpec</span><span class="keyglyph">@</span><span class="layout">(</span><span class="conid">ExContr</span> <span class="layout">(</span><span class="varid">contractId</span><span class="layout">,</span> <span class="varid">args</span><span class="layout">,</span> <span class="varid">lattice</span><span class="layout">)</span><span class="layout">)</span> <span class="keyglyph">=</span>
   <span class="keyword">let</span> <span class="varid">pr</span> <span class="keyglyph">=</span> <span class="varid">evalEx</span> <span class="varid">exSpec</span>
       <span class="varid">expValChart</span> <span class="keyglyph">=</span> <span class="keyword">if</span> <span class="varid">contractId</span> <span class="varop">==</span> <span class="str">"probs"</span> <span class="keyword">then</span> <span class="varid">noHtml</span> <span class="comment">-- expected value is meaningless for the probabilities it relies on</span>
                     <span class="keyword">else</span> <span class="varid">h3</span> <span class="varop">&lt;&lt;</span> <span class="str">"Expected value"</span> <span class="varop">+++</span> <span class="varid">image</span> <span class="varop">!</span> <span class="keyglyph">[</span><span class="varid">src</span> <span class="layout">(</span><span class="varid">chartUrl</span> <span class="varop">$</span> <span class="varid">expectedValuePr</span> <span class="varid">pr</span><span class="layout">)</span><span class="keyglyph">]</span>
       <span class="varid">imageType</span> <span class="keyglyph">=</span> <span class="str">"png"</span>
   <span class="keyword">in</span> <span class="keyword">if</span> <span class="varid">useLatticeImage</span> <span class="varid">exSpec</span>
      <span class="keyword">then</span> <span class="keyword">do</span> <span class="varid">baseName</span> <span class="keyglyph">&lt;-</span> <span class="varid">mkUniqueName</span> <span class="varid">baseDotFilename</span>
              <span class="varid">exitCode</span> <span class="keyglyph">&lt;-</span> <span class="varid">latticeImage</span> <span class="varid">pr</span> <span class="layout">(</span><span class="varid">webPath</span> <span class="varop">++</span> <span class="varid">tmpImgPath</span> <span class="varop">++</span> <span class="varid">baseName</span><span class="layout">)</span> <span class="varid">imageType</span>
              <span class="keyword">let</span> <span class="varid">pageContents</span> <span class="keyglyph">=</span>
                    <span class="keyword">case</span> <span class="varid">exitCode</span> <span class="keyword">of</span>
                      <span class="conid">ExitSuccess</span> <span class="keyglyph">-&gt;</span> <span class="varid">renderExampleForm</span> <span class="varid">exSpec</span> <span class="layout">(</span><span class="varid">image</span> <span class="varop">!</span> <span class="keyglyph">[</span><span class="varid">src</span> <span class="varid">latticeUrl</span><span class="layout">,</span> <span class="varid">border</span> <span class="num">1</span><span class="keyglyph">]</span><span class="layout">)</span> <span class="varid">expValChart</span>
                                      <span class="keyword">where</span> <span class="varid">latticeUrl</span> <span class="keyglyph">=</span> <span class="str">"/"</span> <span class="varop">++</span> <span class="varid">tmpImgPath</span> <span class="varop">++</span> <span class="varid">baseName</span> <span class="varop">++</span> <span class="str">"."</span> <span class="varop">++</span> <span class="varid">imageType</span>
                      <span class="keyword">_</span> <span class="keyglyph">-&gt;</span> <span class="varid">p</span> <span class="varop">&lt;&lt;</span> <span class="str">"renderEx: error generating lattice image"</span>
              <span class="varid">return</span> <span class="varop">$</span> <span class="varid">renderExamplePage</span> <span class="varid">pageContents</span>
      <span class="keyword">else</span> <span class="varid">return</span> <span class="varop">$</span> <span class="varid">renderExamplePage</span> <span class="varop">$</span> <span class="varid">renderExampleForm</span> <span class="varid">exSpec</span> <span class="layout">(</span><span class="varid">prToTable</span> <span class="varid">pr</span><span class="layout">)</span> <span class="varid">expValChart</span>
</pre>
<pre> <span class="varid">renderExDefault</span> <span class="keyglyph">=</span> <span class="varid">renderExamplePage</span> <span class="varop">$</span>
                     <span class="varid">renderExampleForm</span> <span class="layout">(</span><span class="conid">ExContr</span> <span class="layout">(</span><span class="str">"zcb"</span><span class="layout">,</span> <span class="keyglyph">[</span><span class="varid">fromIntegral</span> <span class="varid">t1Horizon</span><span class="layout">,</span> <span class="num">10</span><span class="keyglyph">]</span><span class="layout">,</span> <span class="conid">True</span><span class="layout">)</span><span class="layout">)</span>
                                       <span class="varid">noHtml</span> <span class="varid">noHtml</span>
</pre>
<pre> <span class="varid">renderExamplePage</span> <span class="varid">contents</span> <span class="keyglyph">=</span> <span class="varid">renderPage</span> <span class="varid">pageTitle</span> <span class="varop">$</span>
       <span class="varid">p</span> <span class="varop">!</span> <span class="keyglyph">[</span><span class="varid">align</span> <span class="str">"right"</span><span class="keyglyph">]</span> <span class="varop">&lt;&lt;</span> <span class="varid">anchor</span> <span class="varop">!</span> <span class="keyglyph">[</span><span class="varid">href</span> <span class="str">"/Contracts.html"</span><span class="keyglyph">]</span> <span class="varop">&lt;&lt;</span> <span class="str">"Source code"</span>
   <span class="varop">+++</span> <span class="varid">contents</span>
</pre>
<pre> <span class="varid">renderPage</span> <span class="keyglyph">::</span> <span class="layout">(</span><span class="conid">HTML</span> <span class="varid">a</span><span class="layout">,</span> <span class="conid">HTML</span> <span class="varid">b</span><span class="layout">)</span> <span class="keyglyph">=&gt;</span> <span class="varid">a</span> <span class="keyglyph">-&gt;</span> <span class="varid">b</span> <span class="keyglyph">-&gt;</span> <span class="conid">Html</span>
 <span class="varid">renderPage</span> <span class="varid">hdg</span> <span class="varid">contents</span> <span class="keyglyph">=</span> <span class="layout">(</span><span class="varid">header</span> <span class="varop">&lt;&lt;</span> <span class="layout">(</span><span class="varid">styleSheet</span> <span class="varop">+++</span> <span class="varid">thetitle</span> <span class="varop">&lt;&lt;</span> <span class="varid">hdg</span><span class="layout">)</span><span class="layout">)</span>
                           <span class="varop">+++</span> <span class="layout">(</span><span class="varid">body</span> <span class="varop">&lt;&lt;</span> <span class="layout">(</span><span class="varid">h1</span> <span class="varop">&lt;&lt;</span> <span class="varid">hdg</span> <span class="varop">+++</span> <span class="varid">contents</span><span class="layout">)</span><span class="layout">)</span>
</pre>
<pre> <span class="varid">styleSheet</span> <span class="keyglyph">::</span> <span class="conid">Html</span>
 <span class="varid">styleSheet</span> <span class="keyglyph">=</span> <span class="varid">thelink</span> <span class="varop">!</span> <span class="keyglyph">[</span><span class="varid">rel</span> <span class="str">"stylesheet"</span><span class="layout">,</span> <span class="varid">thetype</span> <span class="str">"text/css"</span><span class="layout">,</span> <span class="varid">href</span> <span class="str">"/contracts.css"</span> <span class="keyglyph">]</span> <span class="varop">&lt;&lt;</span> <span class="varid">noHtml</span>
</pre>
evalEx evaluates the contract specified by ExContr.  Instead of pattern matching on the ExContr here, 
to avoid duplication it uses the <code>examples</code> list which is used in generating the web form.

<pre> <span class="varid">evalEx</span> <span class="keyglyph">::</span> <span class="conid">ExContr</span> <span class="keyglyph">-&gt;</span> <span class="conid">PR</span> <span class="conid">Double</span>
 <span class="varid">evalEx</span> <span class="layout">(</span><span class="conid">ExContr</span> <span class="layout">(</span><span class="varid">name</span><span class="layout">,</span> <span class="varid">args</span><span class="layout">,</span> <span class="varid">f</span><span class="layout">)</span><span class="layout">)</span> <span class="keyglyph">=</span>
   <span class="keyword">case</span> <span class="varid">lookup</span> <span class="varid">name</span> <span class="varid">examples</span> <span class="keyword">of</span>
     <span class="conid">Just</span> <span class="layout">(</span><span class="varid">desc</span><span class="layout">,</span> <span class="varid">defaultArgs</span><span class="layout">,</span> <span class="varid">f</span><span class="layout">)</span> <span class="keyglyph">-&gt;</span> <span class="keyword">if</span> <span class="varid">length</span> <span class="varid">args</span> <span class="varop">&gt;=</span> <span class="varid">length</span> <span class="varid">defaultArgs</span> <span class="comment">-- ignore extra args</span>
                                    <span class="keyword">then</span> <span class="varid">f</span> <span class="varid">args</span>          <span class="comment">-- TODO: could handle argument defaulting here? See getArg.</span>
                                    <span class="keyword">else</span> <span class="varid">dummyContract</span>
     <span class="keyword">_</span> <span class="keyglyph">-&gt;</span> <span class="varid">dummyContract</span>
   <span class="keyword">where</span>
     <span class="varid">dummyContract</span> <span class="keyglyph">=</span> <span class="varid">evalX</span> <span class="varop">$</span> <span class="varid">zcb</span> <span class="varid">time0</span> <span class="num">0</span> <span class="conid">USD</span> <span class="comment">-- TODO: proper error reporting (to web page if appropriate)</span>
</pre>
Limit server abuse - disallow large lattices in web interface.  The program can easily handle thousands of time steps, but generating a graphic of the resulting lattice produces large files and consumes CPU resources.  To experiment with larger trees, run Contracts.lhs on your own machine.

<pre> <span class="varid">sanitize</span> <span class="varid">r</span> <span class="keyglyph">=</span> <span class="varid">min</span> <span class="layout">(</span><span class="varid">truncate</span> <span class="varid">r</span><span class="layout">)</span> <span class="num">20</span>
</pre>
Map an example id to a description, default arguments, and an evaluation function.

<pre> <span class="varid">examples</span> <span class="keyglyph">=</span>
   <span class="comment">-- Contracts</span>
   <span class="keyglyph">[</span><span class="layout">(</span><span class="str">"zcb"</span><span class="layout">,</span>   <span class="layout">(</span><span class="str">"Zero-coupon bond"</span><span class="layout">,</span>    <span class="keyglyph">[</span><span class="varid">t1Horizon</span><span class="layout">,</span> <span class="num">10</span><span class="keyglyph">]</span><span class="layout">,</span>
                                           <span class="layout">(</span><span class="keyglyph">\</span><span class="layout">(</span><span class="varid">r</span><span class="conop">:</span><span class="varid">x</span><span class="conop">:</span><span class="keyword">_</span><span class="layout">)</span> <span class="keyglyph">-&gt;</span> <span class="varid">evalX</span> <span class="varop">$</span> <span class="varid">zcb</span> <span class="layout">(</span><span class="varid">mkDate</span> <span class="varop">$</span> <span class="varid">sanitize</span> <span class="varid">r</span><span class="layout">)</span> <span class="varid">x</span> <span class="conid">USD</span><span class="layout">)</span><span class="layout">)</span><span class="layout">)</span>
   <span class="layout">,</span><span class="layout">(</span><span class="str">"c11"</span><span class="layout">,</span>   <span class="layout">(</span><span class="str">"European option"</span><span class="layout">,</span>     <span class="conid">[]</span><span class="layout">,</span>  <span class="layout">(</span><span class="keyglyph">\</span><span class="keyword">_</span>       <span class="keyglyph">-&gt;</span> <span class="varid">evalX</span> <span class="varid">c11</span><span class="layout">)</span><span class="layout">)</span><span class="layout">)</span>
   <span class="comment">-- Underlyings</span>
   <span class="layout">,</span><span class="layout">(</span><span class="str">"probs"</span><span class="layout">,</span> <span class="layout">(</span><span class="str">"Probability lattice"</span><span class="layout">,</span> <span class="keyglyph">[</span><span class="num">9</span><span class="keyglyph">]</span><span class="layout">,</span> <span class="layout">(</span><span class="keyglyph">\</span><span class="layout">(</span><span class="varid">r</span><span class="conop">:</span><span class="keyword">_</span><span class="layout">)</span>   <span class="keyglyph">-&gt;</span> <span class="keyword">let</span> <span class="varid">n</span> <span class="keyglyph">=</span> <span class="varid">sanitize</span> <span class="varid">r</span> <span class="varop">+</span> <span class="num">1</span> <span class="keyword">in</span> <span class="conid">PR</span> <span class="varop">$</span> <span class="varid">take</span> <span class="varid">n</span> <span class="varid">probabilityLattice</span><span class="layout">)</span><span class="layout">)</span><span class="layout">)</span>
   <span class="layout">,</span><span class="layout">(</span><span class="str">"rates"</span><span class="layout">,</span> <span class="layout">(</span><span class="str">"Interest rate model"</span><span class="layout">,</span> <span class="keyglyph">[</span><span class="num">9</span><span class="keyglyph">]</span><span class="layout">,</span> <span class="layout">(</span><span class="keyglyph">\</span><span class="layout">(</span><span class="varid">r</span><span class="conop">:</span><span class="keyword">_</span><span class="layout">)</span>   <span class="keyglyph">-&gt;</span> <span class="keyword">let</span> <span class="varid">n</span> <span class="keyglyph">=</span> <span class="varid">sanitize</span> <span class="varid">r</span> <span class="varop">+</span> <span class="num">1</span> <span class="keyword">in</span> <span class="varid">takePr</span> <span class="varid">n</span> <span class="varop">$</span> <span class="varid">rateModel</span> <span class="varid">xm</span> <span class="conid">USD</span><span class="layout">)</span><span class="layout">)</span><span class="layout">)</span><span class="keyglyph">]</span>
</pre>

<pre> <span class="varid">renderExampleForm</span> <span class="layout">(</span><span class="conid">ExContr</span> <span class="layout">(</span><span class="varid">contractId</span><span class="layout">,</span> <span class="varid">args</span><span class="layout">,</span> <span class="varid">showImage</span><span class="layout">)</span><span class="layout">)</span> <span class="varid">chart1</span> <span class="varid">chart2</span> <span class="keyglyph">=</span>
   <span class="varid">form</span> <span class="varop">!</span> <span class="keyglyph">[</span><span class="varid">method</span> <span class="str">"GET"</span><span class="layout">,</span> <span class="varid">action</span> <span class="str">"/contractEx"</span><span class="keyglyph">]</span>
     <span class="varop">&lt;&lt;</span> <span class="varid">table</span> <span class="varop">&lt;&lt;</span> <span class="layout">(</span><span class="layout">(</span><span class="varid">tr</span> <span class="varop">&lt;&lt;</span> <span class="layout">(</span><span class="varid">td</span> <span class="varop">&lt;&lt;</span> <span class="str">"Contract"</span> <span class="varop">+++</span> <span class="varid">td</span> <span class="varop">&lt;&lt;</span> <span class="str">"Horizon"</span> <span class="varop">+++</span> <span class="varid">td</span> <span class="varop">&lt;&lt;</span> <span class="str">"Value"</span> <span class="varop">+++</span> <span class="varid">td</span> <span class="varop">&lt;&lt;</span> <span class="str">"Output"</span><span class="layout">)</span><span class="layout">)</span>
              <span class="varop">+++</span> <span class="layout">(</span><span class="varid">tr</span> <span class="varop">&lt;&lt;</span> <span class="layout">(</span><span class="layout">(</span><span class="varid">td</span> <span class="varop">$</span> <span class="varid">select</span> <span class="varop">!</span> <span class="keyglyph">[</span><span class="varid">name</span> <span class="str">"contract"</span><span class="keyglyph">]</span>
                                      <span class="varop">&lt;&lt;</span> <span class="layout">(</span><span class="varid">map</span> <span class="layout">(</span><span class="keyglyph">\</span><span class="layout">(</span><span class="varid">id</span><span class="layout">,</span> <span class="layout">(</span><span class="varid">desc</span><span class="layout">,</span> <span class="varid">defaultArgs</span><span class="layout">,</span> <span class="keyword">_</span><span class="layout">)</span><span class="layout">)</span> <span class="keyglyph">-&gt;</span>
                                                  <span class="varid">attrIf</span> <span class="layout">(</span><span class="varid">id</span> <span class="varop">==</span> <span class="varid">contractId</span><span class="layout">)</span> <span class="varid">selected</span> <span class="layout">(</span><span class="varid">option</span> <span class="varop">!</span> <span class="keyglyph">[</span><span class="varid">value</span> <span class="varid">id</span><span class="keyglyph">]</span><span class="layout">)</span> <span class="varop">&lt;&lt;</span> <span class="varid">desc</span><span class="layout">)</span>
                                              <span class="varid">examples</span><span class="layout">)</span><span class="layout">)</span>
                      <span class="varop">+++</span> <span class="layout">(</span><span class="varid">td</span> <span class="varop">&lt;&lt;</span> <span class="varid">textfield</span> <span class="str">"arg1"</span> <span class="varop">!</span> <span class="keyglyph">[</span><span class="varid">value</span> <span class="varop">$</span> <span class="varid">getArg</span> <span class="varid">contractId</span> <span class="varid">args</span> <span class="num">0</span><span class="layout">,</span> <span class="varid">size</span> <span class="str">"10"</span><span class="keyglyph">]</span><span class="layout">)</span>
                      <span class="varop">+++</span> <span class="layout">(</span><span class="varid">td</span> <span class="varop">&lt;&lt;</span> <span class="varid">textfield</span> <span class="str">"arg2"</span> <span class="varop">!</span> <span class="keyglyph">[</span><span class="varid">value</span> <span class="varop">$</span> <span class="varid">getArg</span> <span class="varid">contractId</span> <span class="varid">args</span> <span class="num">1</span><span class="layout">,</span> <span class="varid">size</span> <span class="str">"10"</span><span class="keyglyph">]</span><span class="layout">)</span>
                      <span class="varop">+++</span> <span class="layout">(</span><span class="varid">td</span> <span class="varop">&lt;&lt;</span> <span class="layout">(</span><span class="varid">attrIf</span>      <span class="varid">showImage</span>  <span class="varid">checked</span> <span class="layout">(</span><span class="varid">radio</span> <span class="str">"image"</span> <span class="str">"True"</span><span class="layout">)</span>  <span class="varop">+++</span> <span class="str">"Image"</span><span class="layout">)</span><span class="layout">)</span><span class="layout">)</span><span class="layout">)</span>
              <span class="varop">+++</span> <span class="layout">(</span><span class="varid">tr</span>  <span class="varop">&lt;&lt;</span> <span class="layout">(</span><span class="varid">td</span> <span class="varop">&lt;&lt;</span> <span class="varid">submit</span> <span class="str">"submit"</span> <span class="str">"Draw"</span> <span class="varop">+++</span> <span class="varid">spacer</span> <span class="num">2</span>
                       <span class="varop">+++</span> <span class="varid">td</span> <span class="varop">&lt;&lt;</span> <span class="layout">(</span><span class="varid">attrIf</span> <span class="layout">(</span><span class="varid">not</span> <span class="varid">showImage</span><span class="layout">)</span> <span class="varid">checked</span> <span class="layout">(</span><span class="varid">radio</span> <span class="str">"image"</span> <span class="str">"False"</span><span class="layout">)</span> <span class="varop">+++</span> <span class="str">"Table"</span><span class="layout">)</span><span class="layout">)</span><span class="layout">)</span><span class="layout">)</span>
     <span class="varop">+++</span> <span class="varid">chart1</span> <span class="varop">+++</span> <span class="varid">hr</span> <span class="varop">+++</span> <span class="varid">chart2</span>
</pre>
Retrieve the nth argument from the argument array; if not present, retrieve from default args for specified example.

<pre> <span class="varid">getArg</span> <span class="varid">id</span> <span class="varid">l</span> <span class="varid">n</span> <span class="keyglyph">=</span> <span class="keyword">if</span> <span class="varid">n</span> <span class="varop">&lt;</span> <span class="varid">length</span> <span class="varid">l</span> <span class="keyword">then</span> <span class="varid">show</span> <span class="varop">$</span> <span class="varid">l</span> <span class="varop">!!</span> <span class="varid">n</span>
                 <span class="keyword">else</span> <span class="keyword">case</span> <span class="varid">lookup</span> <span class="varid">id</span> <span class="varid">examples</span> <span class="keyword">of</span>
                        <span class="conid">Just</span> <span class="layout">(</span><span class="keyword">_</span><span class="layout">,</span> <span class="varid">args</span><span class="layout">,</span> <span class="keyword">_</span><span class="layout">)</span> <span class="keyglyph">-&gt;</span> <span class="keyword">if</span> <span class="varid">n</span> <span class="varop">&lt;</span> <span class="varid">length</span> <span class="varid">args</span>
                                             <span class="keyword">then</span> <span class="varid">show</span> <span class="varop">$</span> <span class="varid">args</span> <span class="varop">!!</span> <span class="varid">n</span> <span class="keyword">else</span> <span class="str">""</span>
</pre>
attrIf adds the specified attribute to the Html element if the condition is true.
Useful for <code>checked</code> and <code>selected</code> attributes.

<pre> <span class="varid">attrIf</span> <span class="conid">False</span> <span class="varid">attr</span> <span class="varid">el</span> <span class="keyglyph">=</span> <span class="varid">el</span>
 <span class="varid">attrIf</span> <span class="conid">True</span>  <span class="varid">attr</span> <span class="varid">el</span> <span class="keyglyph">=</span> <span class="varid">el</span> <span class="varop">!</span> <span class="keyglyph">[</span><span class="varid">attr</span><span class="keyglyph">]</span>
</pre>

<h2 id="appendixF">Appendix F - HAppS server integration</h2>

<p>
The following module can be used to integrate with the <a href="http://web.archive.org/web/20130326233424/http://happs.org/">HAppS</a> application server.
This provides a <a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/contractEx">web interface</a> to the system.  
</p><p>
This code is not an executable part of Contracts.lhs.  To use it, it should be extracted to its own file and built with HAppS.  The <code>import Contracts</code> line imports Contracts.lhs (this file).
</p>

<pre>module Main where

import HAppS.Server.AlternativeHTTP
import HAppS.Server.HTTP.AltFileServe
import Control.Monad.State
import Numeric

import Contracts

instance FromData ExContr where
  fromData = do c    &lt;- look "contract"
                arg1 &lt;- look "arg1"
                arg2 &lt;- look "arg2"
                img  &lt;- look "image"
                return $ ExContr (c, map fst $ readFloat arg1
                                            ++ readFloat arg2, read img)

main :: IO ()
main = do simpleHTTP [dir "contractEx"
                        [withData $ \(ExContr t) -&gt;
                           [anyRequest $ liftIO $ do out &lt;- renderEx (ExContr t)
                                                     return $ toResponse out]
                        ,anyRequest $ ok $ toResponse renderExDefault]
                     ,fileServe ["Contracts.html"] "public" -- fileserving
                     ]
</pre>


<h2 id="references">References</h2>
<ol type="A">
<li id="paperA"><a href="http://web.archive.org/web/20130326233424/http://research.microsoft.com/Users/simonpj/Papers/financial-contracts/contracts-icfp.ps.gz">
Composing contracts: an adventure in financial engineering</a></li>
<li id="paperB"><a href="http://web.archive.org/web/20130326233424/http://research.microsoft.com/Users/simonpj/Papers/financial-contracts/pj-eber.ps">
How to write a financial contract</a></li>
<li id="paperC"><a href="http://web.archive.org/web/20130326233424/http://citeseer.ist.psu.edu/elliott97functional.html">
Functional Reactive Animation</a></li>
</ol>

<h2 id="credits">Credits</h2>
<p>
First, thanks to the authors of the original papers - Simon Peyton Jones, Jean-Marc Eber, and Julian Seward - for some fascinating and useful papers.
</p><p>
Thanks also to Thomas Hartman, Jeff Polakow, Adam Peacock, Chung-Chieh Shan and the organizers and members of the <a href="http://web.archive.org/web/20130326233424/http://lisp.meetup.com/59/">New York Functional Programmers Meetup Group</a> for their encouragement and support.
</p><p>
The HTML version of this document was generated from <a href="http://web.archive.org/web/20130326233424/http://contracts.scheming.org/Contracts.lhs">Contracts.lhs</a> using <a href="http://web.archive.org/web/20130326233424/http://www.cs.york.ac.uk/fp/darcs/hscolour/">hscolour</a> with the -lit and -css options to color only the code fragments.  Worked like a charm.  (The rest of the HTML was written by hand.)
</p>




<div id="feedly-mini" title="feedly Mini tookit"></div></body></html>